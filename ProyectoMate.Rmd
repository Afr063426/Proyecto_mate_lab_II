---
title: "Proyecto"
author: "Daniel Sabater"
date: '2022-06-05'
output: html_document
---

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
# Programacion hecha por Joshua Cervantes, Moisés Monge y Daniel Sabater
# Se cargan los paquetes
knitr::opts_chunk$set(echo = FALSE)
options(scipen = 999)
library(lifecontingencies)
library(tidyverse)
library(lubridate)
library(readxl)
library(kableExtra)
library(xtable)
library(stringr)
library(magrittr) # uso de %<>% con funciones de dplyr


# Para paralelizar
library(future.apply)
plan(multicore)

# Se cargan las bases de datos

Afiliados_31_12_2021 <- read_excel("Planilla_Compañia_31_12_2021.xlsx")
Pensionados_31_12_2021 <- read_excel("Compañia_Pensionados_31_12_2021.xlsx", range = "A1:F5006")


# Tablas de decrementos

TablasDecrementosHombres <- read_excel("Tablas de decrementos.xlsx",
  sheet = "Hombres"
)
TablasDecrementosMujeres <- read_excel("Tablas de decrementos.xlsx",
  sheet = "Mujeres"
)


# Tablas de mortalidad dinámicas


TablaDinamica_lxsHombres <- as.data.frame(read_excel("TablaDinamica-lxs.xlsx",
  sheet = "Hombres"
))
TablaDinamica_lxsMujeres <- as.data.frame(read_excel("TablaDinamica-lxs.xlsx",
  sheet = "Mujeres"
))


# Se genera lista con las tablas actuariales de los hombres

ListaDeTablasHombres <- list()
for (j in 1:(length(TablaDinamica_lxsHombres) - 1)) {
  ListaDeTablasHombres[[j]] <- with(
    TablaDinamica_lxsHombres,
    new(
      "actuarialtable",
      interest = 0.06,
      x = TablaDinamica_lxsHombres[, 1],
      lx = TablaDinamica_lxsHombres[, j + 1],
      name = paste("E", (j - 1), sep = "")
    )
  )
}

names(ListaDeTablasHombres) <- paste("E", seq(0, 115), sep = "")

# Se genera lista con las tablas actuariales de las mujeres

ListaDeTablasMujeres <- list()
for (j in 1:(length(TablaDinamica_lxsMujeres) - 1)) {
  ListaDeTablasMujeres[[j]] <- with(
    TablaDinamica_lxsMujeres,
    new(
      "actuarialtable",
      interest = 0.06,
      x = TablaDinamica_lxsMujeres[, 1],
      lx = TablaDinamica_lxsMujeres[, j + 1],
      name = paste("E", (j - 1), sep = "")
    )
  )
}

names(ListaDeTablasMujeres) <- paste("E", seq(0, 115), sep = "")

# Se establece la fecha de la valuación

dia_de_evaluacion <- as.Date("31/12/2021", format = "%d/%m/%Y")

# Afiliados

# Cálculo de edades afiliados

edad <- floor(time_length(difftime(
  dia_de_evaluacion,
  as.Date(as.POSIXct(Afiliados_31_12_2021$Fecha_nacimiento), "UTC")
), "years"))

# Depuración de la columna 'Fecha_ingreso'

Afiliados_31_12_2021 %<>% mutate(Fecha_ingreso = paste(substr(Fecha_ingreso, 1, 4),
  "/", substr(Fecha_ingreso, 5, 6), "/", substr(Fecha_ingreso, 7, 8),
  sep = ""
))

# Depuración de la columna 'Fecha_nacimiento'

Afiliados_31_12_2021 %<>% mutate(Fecha_nacimiento = format(Fecha_nacimiento, "%Y/%m/%d"))

# Cálculo de antigüedad

antiguedad <- floor(time_length(difftime(
  dia_de_evaluacion,
  as.Date(
    Afiliados_31_12_2021$Fecha_ingreso,
    "%Y/%m/%d"
  )
), "years"))

# Inclusión de las variables de edad y antigüedad en la base de datos

Afiliados_31_12_2021 %<>% mutate("Edad" = edad, "Antiguedad" = antiguedad)

# Se calcula edad de los pensionados

Pensionados_31_12_2021 %<>% mutate(FEC_NAC = paste(substr(FEC_NAC, 1, 4),
  "/", substr(FEC_NAC, 5, 6), "/", substr(FEC_NAC, 7, 8),
  sep = ""
))

Pensionados_31_12_2021 %<>% mutate(FEC_RIG_PEN = paste(substr(FEC_RIG_PEN, 1, 4),
  "/", substr(FEC_RIG_PEN, 5, 6), "/", substr(FEC_RIG_PEN, 7, 8),
  sep = ""
))

edad <- floor(time_length(
  difftime(
    dia_de_evaluacion,
    as.Date(
      Pensionados_31_12_2021$FEC_NAC,
      "%Y/%m/%d"
    )
  ),
  "years"
))

tiempo_pension <- floor(time_length(
  difftime(
    dia_de_evaluacion,
    as.Date(
      Pensionados_31_12_2021$FEC_RIG_PEN,
      "%Y/%m/%d"
    )
  ),
  "years"
))

Pensionados_31_12_2021 %<>% mutate("Edad" = edad, "T_Pension" = tiempo_pension)

# se crean bases de datos según genero

afil_hombres <- Afiliados_31_12_2021 %>% filter(Sexo == "M")
pen_hombres <- Pensionados_31_12_2021 %>% filter(SEX == "M")
afil_mujeres <- Afiliados_31_12_2021 %>% filter(Sexo == "F")
pen_mujeres <- Pensionados_31_12_2021 %>% filter(SEX == "F")

# Inflacion
inflacion <- 0.04

# Aumentos real
aumento_real <- 0.0150

# Porcentaje de aporte
porcentaje_aporte <- 0.015

# Interes
interes <- 0.07
#
```

## Tablas de multiples decrementos


```{r message=FALSE, warning=FALSE}

ProMuerte <- function(q1, q2, q3, q4) {
  a <- q1 * ((-3 * q2 * q3 * q4) / 12 + 4 * (q2 * q3 + q3 * q4 + q4 * q2) / 12 - 6 * (q2 + q3 + q4) / 12 + 1)
  b <- q2 * ((-3 * q1 * q3 * q4) / 12 + 4 * (q1 * q3 + q3 * q4 + q4 * q1) / 12 - 6 * (q1 + q3 + q4) / 12 + 1)
  c <- q3 * ((-3 * q2 * q1 * q4) / 12 + 4 * (q2 * q1 + q1 * q4 + q4 * q2) / 12 - 6 * (q2 + q1 + q4) / 12 + 1)
  d <- q4 * ((-3 * q2 * q3 * q1) / 12 + 4 * (q2 * q3 + q3 * q1 + q1 * q2) / 12 - 6 * (q2 + q3 + q1) / 12 + 1)
  qx <- (a + b + c + d)

  return(data.frame("qx1" = a, "qx2" = b, "qx3" = c, "qx4" = d, "qxC" = qx))
}

# Se genera lista con las tablas de multiples decrementos de los hombres

MDListaDeTablasHombres <- list()
for (m in 1:116) {
  qxs <- ProMuerte(TablasDecrementosHombres$Invalidez, TablasDecrementosHombres$Jubilacion, TablasDecrementosHombres$Retiro, qxt(ListaDeTablasHombres[[m]], 0:115, 1))

  Tabladevida <- as.data.frame(qxs)

  Tabladevida$lx <- (1000000:(1000000 - 115))

  for (i in 1:115) {
    Tabladevida$lx[i + 1] <- Tabladevida$lx[i] - Tabladevida$lx[i] * Tabladevida$qxC[i]
  }

  Tabladevida$d1 <- Tabladevida$lx * Tabladevida$qx1
  Tabladevida$d2 <- Tabladevida$lx * Tabladevida$qx2
  Tabladevida$d3 <- Tabladevida$lx * Tabladevida$qx3
  Tabladevida$d4 <- Tabladevida$lx * Tabladevida$qx4

  Tabladevida$d4[1] + Tabladevida$lx[2]

  MDListaDeTablasHombres[[m]] <-
    new(
      "mdt",
      table = Tabladevida[, 7:10],
      name = paste("E", (m - 1), sep = "")
    )
}

names(MDListaDeTablasHombres) <- paste("E", seq(0, 115), sep = "")



# Se genera lista con las tablas de multiples decrementos de las mujeres

MDListaDeTablasMujeres <- list()
for (m in 1:116) {
  qxs <- ProMuerte(TablasDecrementosMujeres$Invalidez, TablasDecrementosMujeres$Jubilacion, TablasDecrementosMujeres$Retiro, qxt(ListaDeTablasMujeres[[m]], 0, c(1:116)))

  Tabladevida <- as.data.frame(qxs)

  Tabladevida$lx <- (1000000:(1000000 - 115))

  for (i in 1:115) {
    Tabladevida$lx[i + 1] <- Tabladevida$lx[i] - Tabladevida$lx[i] * Tabladevida$qxC[i]
  }

  Tabladevida$d1 <- Tabladevida$lx * Tabladevida$qx1
  Tabladevida$d2 <- Tabladevida$lx * Tabladevida$qx2
  Tabladevida$d3 <- Tabladevida$lx * Tabladevida$qx3
  Tabladevida$d4 <- Tabladevida$lx * Tabladevida$qx4

  Tabladevida$d4[1] + Tabladevida$lx[2]

  MDListaDeTablasMujeres[[m]] <-
    new(
      "mdt",
      table = Tabladevida[, 7:10],
      name = paste("E", (m - 1), sep = "")
    )
}

names(MDListaDeTablasMujeres) <- paste("E", seq(0, 115), sep = "")

rm(qxs)
```

Las tablas de decrementos constituyen
 Decremento 1: invalidez
 Decremento 2: jubilación
 Decremento 3: retiro
 Decremento 4: muerte

 
 
# Funciones que nos sirven a todos


```{r}
# porcentaje de pensión
porcentaje_de_pension <- function(antiguedad) {
  
  porcebtajeVejez <- c((antiguedad >= 5 & antiguedad < 10) * 0.10 +
                         (antiguedad >= 10 & antiguedad < 15) * 0.15 +
                         (antiguedad >= 15 & antiguedad < 20) * 0.20 +
                         (antiguedad >= 20 & antiguedad < 25) * 0.25 +
                         (antiguedad >= 25 & antiguedad < 30) * 0.30 +
                         (antiguedad >= 30 & antiguedad < 35) * 0.35 +
                         (antiguedad >= 35) * 0.4)
  
return(porcebtajeVejez)
}


beneficio <- function(antiguedad, decremento, salario, k) {
  antiguedad<-antiguedad+k
  #invalidez
  if (decremento==1 ) {
    porcentaje_de_salario<-porcentaje_de_pension(antiguedad)*0.6
  #vejez
  }else if(decremento==2){
    porcentaje_de_salario<-porcentaje_de_pension(antiguedad)
  #muerte
  }else if(decremento==4){
    porcentaje_de_salario<-porcentaje_de_pension(antiguedad)*0.2
  }
  return(salario_referencia(antiguedad-k, salario, k)/12 *porcentaje_de_salario) 
}

RebajoFondosInsuficientes <- function(MontodePension) {
  MontoRebajado <- c(
    MontodePension * 0.10 +
      (MontodePension >= 2293400) * 0.35 * MontodePension +
      (MontodePension >= 2866750) * 0.45 * MontodePension +
      (MontodePension >= 3583437.50) * 0.55 * MontodePension +
      (MontodePension >= 4479296.88) * 0.65 * MontodePension
  )
  if (MontoRebajado > MontodePension * 0.55) {
    return(MontodePension * 0.55)
  }
  return(MontoRebajado)
}
```

## Escala salarial

```{r}
# Aqui voy a programar la tabla de escala salarial
# se debe hacer por sexo y por edad
# de momentos se calculará el promedio por edad
# Se estima una función lineal entre los dos puntos que faltan
# Pensando si hacerlo por splines
media_mujeres <- aggregate(afil_mujeres$Salario, list(afil_mujeres$Edad), FUN = mean)
media_hombres <- aggregate(afil_hombres$Salario, list(afil_hombres$Edad), FUN = mean)
j <- 2
while (j <= nrow(media_mujeres)) {
  diferencia <- media_mujeres$Group.1[j] - media_mujeres$Group.1[j - 1]
  if (diferencia != 1) {
    m <- (media_mujeres$x[j] - media_mujeres$x[j - 1]) /
      (media_mujeres$Group.1[j] - media_mujeres$Group.1[j - 1])
    b <- media_mujeres$x[j] - m * media_mujeres$Group.1[j]
    edad_faltantes <- media_mujeres$Group.1[j - 1] + (1:(diferencia - 1))
    montos <- m * edad_faltantes + b
    faltantes <- data.frame(Group.1 = edad_faltantes, x = montos)
    media_mujeres <- rbind(media_mujeres[1:j - 1, ], faltantes, media_mujeres[j:nrow(media_mujeres), ])
  }
  j <- j + 1
}
j <- 2
while (j <= nrow(media_hombres)) {
  diferencia <- media_hombres$Group.1[j] - media_hombres$Group.1[j - 1]
  if (diferencia != 1) {
    m <- (media_hombres$x[j] - media_hombres$x[j - 1]) /
      (media_hombres$Group.1[j] - media_hombres$Group.1[j - 1])
    b <- media_hombres$x[j] - m * media_hombres$Group.1[j]
    edad_faltantes <- media_hombres$Group.1[j - 1] + (1:(diferencia - 1))
    montos <- m * edad_faltantes + b
    faltantes <- data.frame(Group.1 = edad_faltantes, x = montos)
    media_hombres <- rbind(media_hombres[1:j - 1, ], faltantes, media_hombres[j:nrow(media_hombres), ])
  }
  j <- j + 1
}
# Mujeres
edad_m <- max(media_mujeres$Group.1)
sal_m <- rep(max(media_mujeres$x), 85 - edad_m)
sal_m <- data.frame(Group.1 = c((edad_m + 1):85, 18), x = c(sal_m, media_mujeres$x[1]))
media_mujeres %<>% rbind(sal_m)

# Hombres
edad_h <- max(media_hombres$Group.1)
sal_h <- rep(max(media_hombres$x), 85 - edad_h)
sal_h <- data.frame(Group.1 = (edad_h + 1):85, x = sal_h)
media_hombres %<>% rbind(sal_h)

# Ordenamiento
media_mujeres <- media_mujeres[order(media_mujeres$Group.1), ]
media_hombres <- media_hombres[order(media_hombres$Group.1), ]

# Unificacion
escala <- data.frame(Edad = 18:85, Hombres = media_hombres$x, Mujeres = media_mujeres$x)
min_m <- escala$Mujeres[1]
min_h <- escala$Hombres[1]
escala %<>% mutate(Hombres = Hombres / min_h, Mujeres = Mujeres / min_m)
write.csv(escala, "./Escala_edad.csv", row.names = FALSE)
```


## Caso por antigüedad 

```{r}
media_mujeres <- aggregate(afil_mujeres$Salario, list(afil_mujeres$Antiguedad), FUN = mean)
media_hombres <- aggregate(afil_hombres$Salario, list(afil_hombres$Antiguedad), FUN = mean)
j <- 2
while (j <= nrow(media_mujeres)) {
  diferencia <- media_mujeres$Group.1[j] - media_mujeres$Group.1[j - 1]
  if (diferencia != 1) {
    m <- (media_mujeres$x[j] - media_mujeres$x[j - 1]) /
      (media_mujeres$Group.1[j] - media_mujeres$Group.1[j - 1])
    b <- media_mujeres$x[j] - m * media_mujeres$Group.1[j]
    edad_faltantes <- media_mujeres$Group.1[j - 1] + (1:(diferencia - 1))
    montos <- m * edad_faltantes + b
    faltantes <- data.frame(Group.1 = edad_faltantes, x = montos)
    media_mujeres <- rbind(media_mujeres[1:j - 1, ], faltantes, media_mujeres[j:nrow(media_mujeres), ])
  }
  j <- j + 1
}
j <- 2
while (j <= nrow(media_hombres)) {
  diferencia <- media_hombres$Group.1[j] - media_hombres$Group.1[j - 1]
  if (diferencia != 1) {
    m <- (media_hombres$x[j] - media_hombres$x[j - 1]) /
      (media_hombres$Group.1[j] - media_hombres$Group.1[j - 1])
    b <- media_hombres$x[j] - m * media_hombres$Group.1[j]
    edad_faltantes <- media_hombres$Group.1[j - 1] + (1:(diferencia - 1))
    montos <- m * edad_faltantes + b
    faltantes <- data.frame(Group.1 = edad_faltantes, x = montos)
    media_hombres <- rbind(media_hombres[1:j - 1, ], faltantes, media_hombres[j:nrow(media_hombres), ])
  }
  j <- j + 1
}

media_mujeres <- rbind(media_mujeres, data.frame(Group.1 = c(45, 46), x = rep(media_mujeres$x[nrow(media_mujeres)])))
escala_antiguedad <- data.frame(Antiguedad = 0:46, Hombres = media_hombres$x, Mujeres = media_mujeres$x)
min_h <- escala_antiguedad$Hombres[1]
min_m <- escala_antiguedad$Mujeres[1]
escala_antiguedad %<>% mutate(Hombres = Hombres / min_h, Mujeres = Mujeres / min_m)
write.csv(escala_antiguedad, "./Escala_antiguedad.csv", row.names = FALSE)
```


# Estadistica

```{r}
# Ejemplo esperanza de vida
Edad <- 30
exn(ListaDeTablasHombres[[Edad + 1]], x = Edad, type = "curtate")
```



# Estocástico


## Personal activo

Primero, se programa una función que calcula el salario de referencia para el cálculo de la pensión para una persona de edad $x$ empleada activa de la compañía dados:

-`antiguedad`: antigüedad a la edad $x$

-`salario`: salario a la edad $x$

-`k`: cantidad de **años** tras los cuáles la persona sufre algún decremento durante la vida laboral, es decir, a la edad $x+k$. Debe cumplir $k\leq 85 -x$ si la persona es hombre o $k\leq 77-x$ si la persona es mujer. 

Esta función se utiliza en el algortimo de Bacinello (1986) para calcular el salario de referencia una vez simulado que ocurre un decremeno en $k$ años.

```{r Funciones para calcular salarios de referencia}
salario_referencia <- function(antiguedad, salario, k){
  
  # k es el tiempo hasta que ocurre un decremento o se llega a la edad máxima de jubilación

  t <- max(-antiguedad, k - 4):k

  s <- (length(t) - 1):0

  salario_ref <- mean((1.025)^t * (1.04)^(t + s)) * 12 * salario  

  return(salario_ref)
}

salario_referencia_multiple <- function(antiguedad, salario, k) {
  return(sapply(X = k, FUN = salario_referencia, antiguedad = antiguedad, salario = salario))
}
```

Por ejemplo, si una persona de edad $50$ sufre algún decremento $2$ años despúes y tenía a la edad $50$ una antiguedad de $10$ años, entonces el salario de referencia, suponiendo un salario actual de $900,000$ para el cálculo de su pensión es

```{r Ejemplo funcionalidad salario_referencia}
salario_referencia(10, 900000, 2)
```

En segundo lugar, se crea una función que, dado un vector con la distribución de una variable aleatoria discreta $X$ que toma valores en un subconjunto finito de $\mathbb{N}\cup\{0\}$, es decir, un vector de la forma
\[
\bigg( \mathbb{P}(X=0),\mathbb{P}(X\leq 1), \mathbb{P}(X\leq 2),\mathbb{P}(X\leq 3),\dots\bigg),
\]
así como un número $0<p<1$, entonces retorna un valor $k\in\{0,1,2,\dots\}$ tal que

\[
\mathbb{P}(X\leq k-1)<p\leq \mathbb{P}(X\leq k),
\]

que corresponde al $p$-cuantil de $X$. Esta función se utiliza en el algortimo de Bacinello (1986) para hallar el momento de ocurrencia de algún decremento bajo el segundo criterio que plantea dicho método.

```{r Función para localizar cuantiles en modelo estocástico}
hallar_cuantil <- function(distribucion, p) {
  if(p>max(distribucion)){k <- length(distribucion)-1}
  else{
  k <- min(which(p <= distribucion, arr.ind = TRUE))-1
  }
  return(k)
}
```

```{r Función anualidad para modelo estocástico}
# Se crea una función para calcular el monto de los beneficios si ocurre un decremento tras k años y la persona vive t años adicionales
valor_anualidad <- function(k, t, v=1/1.07) {
    if(t==0){t=1}
    vectorMensual <- seq(1 / 12, t, 1 / 12)
    vectoraguinaldo <- c(rep(0, 10), 1, 0)
    vectorAnualmensual <- sort(rep(c(0:(t-1)), 12))
    MontoAPagar <- (1 + 0.04)^(vectorAnualmensual) * 2^vectoraguinaldo
    anualidad <- (v)^(vectorMensual)
    suma1 <- sum(anualidad * MontoAPagar)
    PV_aux <- suma1 * v^(k + 1)
    return(PV_aux)
  }
```

Para calcular los costos asociados a las personas afiliadas al plan ofrecido por la Compañía, se implementa una modificación de uno de los algortimos descritos en Bacinello (1988) bajo un modelo de múltiples decrementos. El mencionado algoritmo permite simular la variable aleatoria $W_{x}$ del tiempo (en años) de trabajo residual de un empleado activo de edad $(x)$. En esencia, el método proporciona un criterio para, en un primer paso y dada una muestra de una distribución $\mathcal{U}(0,1)$, decidir si una persona de edad $(x)$ se llega a jubilar obligatoriamente, en cuyo caso resta solamente simular su tiempo de vida residual. En su defecto, el algoritmo proporciona una regla para asignar, de acuerdo a una segunda muestra de una distribución $\mathcal{U}(0,1)$, cuál de los decrementos restantes sucedió para que no se llegara a la edad máxima de jubilación. Como puede comprobarse, el método requiere a lo sumo dos muestras provenientes de una distribución $\mathcal{U}(0,1)$ en aras de obtener una muestra de $W_{x}$.

Se programa primero la función `costo_afiliado_estocastico`, que retorna una simulación estocástica del costo que representa un afiliado con características:

-`x`: edad actual de la persona. 
-`sexo`: sexo de la persona. Debe estar codificado como "M" o como "F" representando, respectivamente, el sexo masculino o femenino.
-`salario`: salario actual (a la edad $x$)
-`antiguedad`: antigüedad actual de la persona en la Compañía (cantidad de años laborados en la Compañía a la edad $x$)
-`cant_simulaciones`: Cantidad de simulaciones a usar

Asimismo, esta función retorna un valor numérico correspondiente al cálculo del costo para el plan de la Compañía asociado a esta persona de acuerdo al método estocástico.



### Versión con simulación individual

```{r Modelo estocástico individual}

costo_afiliado_estocastico <- function(edad, salario, edad_maxima, antiguedad, cant_simulaciones, lista_tablas_decrementos, lista_tablas_mortalidad) {
  x <- edad
  xi <- edad_maxima
  q4_prima <- lista_tablas_mortalidad[[x + 1]]
  # Se define la distribución del modelo de múltiples decrementos (todas las causas)
  FWx <- qxt(lista_tablas_decrementos[[x + 1]], x = x, t = 1:(xi-x))
  # Se toman muestras uniformes en (0,1) según se especificó
  u <- runif(cant_simulaciones)  
  # PRIMER CRITERIO: Jubilación obligatoria
  # Se cuenta la cantidad escenarios en que ocurrió esta condición: Se comprueba u>FWx(xi-x-1) (se tiene que correr el índice)
  cant_pensiones_edad_maxima <- length(u[u > FWx[xi-x]])
  if(cant_pensiones_edad_maxima==0){
    costos_edad_maxima <- 0
  }else{
    # Se calcula el salario de referencia en este caso
    salario_ref_edad_maxima <- salario_referencia(antiguedad, salario, xi-x)
    # Se simulan los tiempos residuales de vida (en años) para los pensionados de edad máxima (xi)
    tiempos_residuales_edad_maxima <- rLife(n=cant_pensiones_edad_maxima, object = q4_prima, x=xi, k = 1, type = "curtate")
    # Se calculan las anualidades mensuales
    pagos_edad_maxima <- sapply(X=tiempos_residuales_edad_maxima, FUN=valor_anualidad, k=xi-x)/12 
    # Se calculan los costos asociados al primer criterio del algoritmo
    costos_edad_maxima <- salario_ref_edad_maxima * pagos_edad_maxima
  }
  # SEGUNDO CRITERIO: Decremento antes de jubilación por edad máxima
  if(cant_pensiones_edad_maxima<cant_simulaciones){# esta condición significa que hay otros escenarios
      # Debe determinarse cuándo ocurrió el decremento y cuál fue
    # Primero se determina cuándo ocurrió, es decir, se buscan los cuantiles de la distribución de Wx que corresponden a las simulaciones U(0,1) restantes
    cuantiles <- lapply(X = u[u <= FWx[xi-x]], FUN = hallar_cuantil, distribucion = FWx) %>% unlist() 
    # Se calculan las probabilidades condicionales al momento de ocurrencia del decremento
    # Se calculan las probabilidades condicionales al momento de ocurrencia del decremento
    # Primero, se determinan los numeradores
    numeradores <- cbind(
    qxt(lista_tablas_decrementos[[x + 1]], x = x+cuantiles, t = 1, decrement = 1),
    qxt(lista_tablas_decrementos[[x + 1]], x = x+cuantiles, t = 1, decrement = 2),
    qxt(lista_tablas_decrementos[[x + 1]], x = x+cuantiles, t = 1, decrement = 3),
    qxt(lista_tablas_decrementos[[x + 1]], x = x+cuantiles, t = 1, decrement = 4)
  )
    # Segundo, se determinan los denominadores
    denominadores <- apply(X = numeradores, MARGIN = 1, FUN=sum) %>% unlist()
    denominadores[denominadores==0] <- 1 # Para evitar indefiniciones
    # Tercero, se determinan las probabilidades condicionales dividiendo cada fila (numerador) entre el denominador respectivo
    probs_condicionales <- sweep(x=numeradores, MARGIN = 1, STATS = denominadores, FUN = '/' )
    
    # Se determinan los escenarios en que ocurrió cada decremento
    
    # Primero, se tienen que simular nuevas muestras U(0,1) para los casos que no fueron incluidos en el primer criterio
    u <- runif(cant_simulaciones-cant_pensiones_edad_maxima)
    # Se determinan los extramemos de los intervalos de decisión
    extremos_intervalos <- apply(X = probs_condicionales, MARGIN = 1, FUN = cumsum) %>% t()
    
    # INVALIDEZ
    # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por invalidez
    casos_por_invalidez <- u<=extremos_intervalos[,1]
    posiciones_invalidez <- which(casos_por_invalidez , arr.ind = T)
    if(identical(posiciones_invalidez, integer(0))){
      costos_invalidez <- 0
    }else{
      # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
      tiempos_hasta_invalidez <- cuantiles[posiciones_invalidez]
      # Se simulan los tiempos residuales de vida
      tiempos_residuales_invalidez <- lapply(X = x+tiempos_hasta_invalidez, FUN = rLife, n=1, object = q4_prima, k = 1, type = "curtate") %>% unlist()
      
      # Se calculan las anualidades correspondientes
      pagos_invalidez <- mapply(FUN=valor_anualidad, k=tiempos_hasta_invalidez, t=tiempos_residuales_invalidez)/12
      
      # Se calculan los salarios de referencia en este caso
      salarios_ref_invalidez <- lapply(X=tiempos_hasta_invalidez, FUN = salario_referencia, antiguedad=antiguedad, salario=salario) %>% unlist()
      # Se calculan los porcentajes de pensión
      porcentajes_invalidez <- lapply(X=antiguedad+tiempos_hasta_invalidez, FUN=porcentaje_de_pension) %>% unlist()
      # Se calculan los costos por invalidez
      costos_invalidez <- 0.6 * porcentajes_invalidez * salarios_ref_invalidez * pagos_invalidez
    }
    # JUBILACIÓN
    
    # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por jubilación
    casos_por_jubilacion <- extremos_intervalos[,1]<u & u <=extremos_intervalos[,2]
    posiciones_jubilacion <- which(casos_por_jubilacion, arr.ind = T)

    if(identical(posiciones_jubilacion, integer(0))){
      costos_jubilacion <- 0
    }else{
      # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
      tiempos_hasta_jubilacion <- cuantiles[posiciones_jubilacion] 
      
      # Se simulan los tiempos residuales de vida
      tiempos_residuales_jubilacion <- lapply(X = x+tiempos_hasta_jubilacion, FUN = rLife, n=1, object = q4_prima, k = 1, type = "curtate") %>% unlist()
      # Se calculan las anualidades correspondientes
      pagos_jubilacion <- mapply(FUN=valor_anualidad, k=tiempos_hasta_jubilacion, t=tiempos_residuales_jubilacion)/12
      # Se calculan los salarios de referencia en este caso
      salarios_ref_jubilacion <- lapply(X=tiempos_hasta_jubilacion, FUN = salario_referencia, antiguedad=antiguedad, salario=salario) %>% unlist()
      # Se calculan los porcentajes de pensión
      porcentajes_jubilacion <- lapply(X=antiguedad+tiempos_hasta_jubilacion, FUN=porcentaje_de_pension) %>% unlist()
      # Se calculan los costos por jubilacion
      costos_jubilacion <- porcentajes_jubilacion * salarios_ref_jubilacion*pagos_jubilacion
      
    }
    
    # RETIRO
    # casos_por_retiro <- extremos_intervalos[,2]<u & u<=extremos_intervalos[,3]
    # No es necesario calcular nada ya que no les otorga pensión
    
    # MUERTE
    
    # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por muerte
    casos_por_muerte <-extremos_intervalos[,3]<u
    posiciones_muerte <- which(casos_por_muerte, arr.ind = T)
    
    if(identical( posiciones_muerte, integer(0))){
      tiempos_hasta_muerte<-0
    }else{
      # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
      tiempos_hasta_muerte <- cuantiles[posiciones_muerte] 
      # Se calculan las anualidades a 10 años correspondientes
      pagos_muerte <- sapply(X=tiempos_hasta_muerte,FUN=valor_anualidad, t=10)/12
      # Se calculan los salarios de referencia en este caso
      salarios_ref_muerte <- lapply(X=tiempos_hasta_muerte, FUN = salario_referencia, antiguedad=antiguedad, salario=salario) %>% unlist()
      # Se calculan los porcentajes de pensión
      porcentajes_muerte <- lapply(X=antiguedad+tiempos_hasta_muerte, FUN=porcentaje_de_pension) %>% unlist()
      # Se calculan los costos por muerte
      costos_muerte <- 0.2 * porcentajes_muerte * salarios_ref_muerte * pagos_muerte
      
    }
    
  }
  costos_totales_invalidez <- sum(costos_invalidez)/cant_simulaciones
  costos_totales_jubilacion <- sum(costos_jubilacion, costos_edad_maxima)/cant_simulaciones
  costos_totales_muerte <- sum(costos_muerte)/cant_simulaciones
  costos <- c(costos_totales_invalidez, costos_totales_jubilacion, costos_totales_muerte,costos_totales_invalidez+costos_totales_jubilacion+costos_totales_muerte )
    return(costos)
  }

```

```{r Pruebas estocástico individual}
# set.seed(10)
# N <- 10000
# 
# # MUJERES INDIVIDUAL (Leonardo)
# 
# t <- proc.time()
# costos_mujeres <- 1:nrow(afil_mujeres)
# for (i in 1:nrow(afil_mujeres)) {
# edad <- afil_mujeres$Edad[i]
# salario <- afil_mujeres$Salario[i]
# antiguedad <-afil_mujeres$Antiguedad[i]
# costos_mujeres[i] <- costo_afiliado_estocastico(edad, 
#                                              salario, 
#                                              77,
#                                              antiguedad, 
#                                              cant_simulaciones = N,
#                                              MDListaDeTablasMujeres, 
#                                              ListaDeTablasMujeres)
# print(i)  
# }
# proc.time()-t
# archivo <- file("Resultados estocástico individual Mujeres 10000.txt")
# writeLines(paste("Estocastico:", "Mujeres", sum(costos_mujeres)), archivo)
# close(archivo)
# 
# # HOMBRES INDIVIDUAL (Daniel)
# t <- proc.time()
# costos_hombres <- 1:nrow(afil_hombres)
# for (i in 1:nrow(afil_hombres)) {
# edad <- afil_hombres$Edad[i]
# salario <- afil_hombres$Salario[i]
# antiguedad <-afil_hombres$Antiguedad[i]
# costos_hombres[i] <- costo_afiliado_estocastico(edad, 
#                                              salario, 
#                                              85,
#                                              antiguedad, 
#                                              cant_simulaciones = N,
#                                              MDListaDeTablasHombres, 
#                                              ListaDeTablasHombres)
# print(i)
# }
# archivo <- file("Resultados estocástico individual Hombres 10000.txt")
# writeLines(paste("Estocastico:", "Hombres", sum(costos_hombres)), archivo)
# close(archivo)
# proc.time()-t
# t <- proc.time()
# costos_mujeres <- mapply(FUN = costo_afiliado_estocastico,
#                         edad= afil_mujeres$Edad, 
#                                    salario=afil_mujeres$Salario,
#                                    antiguedad=afil_mujeres$Antiguedad,
#                         MoreArgs = list(edad_maxima=77,
#                                         cant_simulaciones=N,                lista_tablas_decrementos=MDListaDeTablasMujeres,
#                                         lista_tablas_mortalidad=ListaDeTablasMujeres),
#                         SIMPLIFY = "vector")
# costos_hombres <- mapply(FUN = costo_afiliado_estocastico,
#                         edad= afil_hombres$Edad, 
#                                    salario=afil_hombres$Salario,
#                                    antiguedad=afil_hombres$Antiguedad,
#                         MoreArgs = list(edad_maxima=85,
#                                         cant_simulaciones=N,                                     
#                                         lista_tablas_decrementos=MDListaDeTablasHombres,
#                                         lista_tablas_mortalidad=ListaDeTablasHombres),
#                         SIMPLIFY = "vector")
# proc.time()-t
# archivo <- file("Resultados Estocástico por persona 100.txt")
# writeLines(paste("Estocastico:", "Mujeres", sum(costos_mujeres), "Hombres", sum(costos_hombres), sep = " "), archivo)
# close(archivo)

# costo_afiliado_estocastico(edad = 50, salario = 10000000, edad_maxima = 85, antiguedad = 10, cant_simulaciones = 50, lista_tablas_decrementos = MDListaDeTablasHombres, lista_tablas_mortalidad = ListaDeTablasHombres)

```


### Versión con simulación por grupos de edad

```{r Modelo estocástico por grupos de edad}
costo_afiliado_estocastico_grupo_etario <- function(edad, salarios, edad_maxima, antiguedades, cant_simulaciones, lista_tablas_decrementos, lista_tablas_mortalidad) {
  x <- edad
  xi <- edad_maxima
  q4_prima <- lista_tablas_mortalidad[[x + 1]]
  # Se define la distribución del modelo de múltiples decrementos (todas las causas)
  FWx <- qxt(lista_tablas_decrementos[[x + 1]], x = x, t = 1:(xi-x))
  # Se toman muestras uniformes en (0,1) según se especificó
  u <- runif(cant_simulaciones)
  # PRIMER CRITERIO
  # Cantidad de casos del primer criterio
  cant_pensiones_edad_maxima <- length(u[u > FWx[xi-x]])
  if (cant_pensiones_edad_maxima == 0) {
    costos_totales_edad_maxima <- 0
  } else {
    # Se simulan los tiempos residuales de vida (en años) para los pensionados de edad máxima (xi)
    tiempos_residuales_edad_maxima <- rLife(n = cant_pensiones_edad_maxima, object = q4_prima, x = xi, k = 1, type = "curtate")
    # Se calculan las anualidades mensuales
    pagos_edad_maxima <- sapply(X=tiempos_residuales_edad_maxima, FUN=valor_anualidad, k=xi-x)/12
    # Se calcula la matriz de salarios
    matriz_salarios_ref_edad_maxima <- mapply(salario_referencia_multiple, antiguedad = antiguedades, salario = salarios, MoreArgs = list(k = rep(xi-x, cant_pensiones_edad_maxima)))
    
    # Se calculan los porcentajes de pensión
    matriz_porcentajes_edad_maxima <- apply(X = outer(antiguedades, rep(xi - x, length(cant_pensiones_edad_maxima)), FUN = "+"), FUN = porcentaje_de_pension, MARGIN = 1)
    
    # Se calculan los costos por edad_maxima
    
    # Matriz con costos por escenario: Personas (columnas) y escenarios (filas)
    
    matriz_costos_edad_maxima <- matriz_porcentajes_edad_maxima * matriz_salarios_ref_edad_maxima * pagos_edad_maxima
    
    # Costos por persona: suma por columna de la matriz de costos
    if(is.matrix(matriz_costos_edad_maxima )){
    costos_edad_maxima_por_persona <-apply(X = matriz_costos_edad_maxima, MARGIN = 2, FUN = sum)
    }else{
      costos_edad_maxima_por_persona <- sapply(X = matriz_costos_edad_maxima, FUN = sum)
    }
    # Suma de los costos de todas las personas
    costos_totales_edad_maxima <- sum(costos_edad_maxima_por_persona)/cant_simulaciones
  }
  # SEGUNDO CRITERIO: Decremento antes de jubilación
  if (cant_pensiones_edad_maxima < cant_simulaciones) { # esta condición significa que hay otros escenarios
    
    # Debe determinarse cuándo ocurrió el decremento y cuál fue
    # Primero se determina cuándo ocurrió, es decir, se buscan los cuantiles de la distribución de Wx que corresponden a las simulaciones U(0,1) restantes
    cuantiles <- lapply(X = u[u <= FWx[xi-x]], FUN = hallar_cuantil, distribucion = FWx) %>% unlist()
    # Se calculan las probabilidades condicionales al momento de ocurrencia del decremento
    # Primero, se determinan los numeradores
    numeradores <- cbind(
    qxt(lista_tablas_decrementos[[x + 1]], x = x+cuantiles, t = 1, decrement = 1),
    qxt(lista_tablas_decrementos[[x + 1]], x = x+cuantiles, t = 1, decrement = 2),
    qxt(lista_tablas_decrementos[[x + 1]], x = x+cuantiles, t = 1, decrement = 3),
    qxt(lista_tablas_decrementos[[x + 1]], x = x+cuantiles, t = 1, decrement = 4)
  )
    # Segundo, se determinan los denominadores
    denominadores <-apply(X = numeradores, MARGIN = 1, FUN = sum) %>% unlist()
    denominadores[denominadores == 0] <- 1 # esto se hace para evitar indefiniciones
    # Tercero, se determinan las probabilidades condicionales dividiendo cada fila (numerador) entre el denominador respectivo
    probs_condicionales <- sweep(x = numeradores, MARGIN = 1, STATS = denominadores, FUN = "/")
    
    # Se determinan los escenarios en que ocurrió cada decremento
    
    # Primero, se tienen que simular nuevas muestras U(0,1) para los casos que no fueron incluidos en el primer criterio
    u <- runif(cant_simulaciones - cant_pensiones_edad_maxima)
    # Se determinan los extramemos de los intervalos de decisión
    extremos_intervalos <- apply(X = probs_condicionales, MARGIN = 1, FUN = cumsum) %>% t()
    
    
    # INVALIDEZ
    
     # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por invalidez
    casos_por_invalidez <- u<=extremos_intervalos[,1]
    posiciones_invalidez <- which(casos_por_invalidez , arr.ind = T)

    if (identical(posiciones_invalidez, integer(0))) {
      costos_totales_invalidez <- 0
    } else {
      # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
      tiempos_hasta_invalidez <- cuantiles[posiciones_invalidez]
      # Se simulan los tiempos residuales de vida
      tiempos_residuales_invalidez <- lapply(X = x + tiempos_hasta_invalidez, FUN = rLife, n = 1, object = q4_prima, k = 1, type = "curtate") %>% unlist()
      
      # Se calculan las anualidades correspondientes
     
       pagos_invalidez <- mapply(FUN=valor_anualidad, k=tiempos_hasta_invalidez, t=tiempos_residuales_invalidez)/12
      
      # Se calculan los salarios de referencia en este caso
      
      matriz_salarios_ref_invalidez <- mapply(salario_referencia_multiple, antiguedad = antiguedades, salario = salarios, MoreArgs = list(k = tiempos_hasta_invalidez))
      
      # Se calculan los porcentajes de pensión
      
      matriz_porcentajes_invalidez <-apply(X = outer(antiguedades, tiempos_hasta_invalidez, FUN = "+"), FUN = porcentaje_de_pension, MARGIN = 1)
      
      # Se calculan los costos por invalidez
      
      # Matriz con costos por escenario: Personas (columnas) y escenarios (filas)
      
      matriz_costos_invalidez <- 0.6 * matriz_porcentajes_invalidez * matriz_salarios_ref_invalidez * pagos_invalidez
      
      # Costos por persona: suma por columna de la matriz de costos
      
      if(is.matrix(matriz_costos_invalidez)){
        costos_invalidez_por_persona <-apply(X = matriz_costos_invalidez, MARGIN = 2, FUN = sum)
      }else{
        costos_invalidez_por_persona <- sapply(X = matriz_costos_invalidez, FUN = sum)
      }
      
      # Suma de los costos de todas las personas
      
      costos_totales_invalidez <- sum(costos_invalidez_por_persona)/cant_simulaciones
    }
    # JUBILACIÓN
    
    # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por jubilación
    
        casos_por_jubilacion <- extremos_intervalos[,1]<u & u<=extremos_intervalos[,2]
    posiciones_jubilacion <- which(casos_por_jubilacion, arr.ind = T)

    if (identical(posiciones_jubilacion, integer(0))) {
      costos_totales_jubilacion <- 0
    } else {
      # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
      tiempos_hasta_jubilacion <- cuantiles[posiciones_jubilacion]
      
      # Se simulan los tiempos residuales de vida
      tiempos_residuales_jubilacion <- lapply(X = x + tiempos_hasta_jubilacion, FUN = rLife, n = 1, object = q4_prima, k = 1, type = "curtate") %>% unlist()
      
      # Se calculan las anualidades correspondientes
      pagos_jubilacion <- mapply(FUN=valor_anualidad, k=tiempos_hasta_jubilacion, t=tiempos_residuales_jubilacion)/12
      # Se calculan los salarios de referencia en este caso
      
      matriz_salarios_ref_jubilacion <- mapply(salario_referencia_multiple, antiguedad = antiguedades, salario = salarios, MoreArgs = list(k = tiempos_hasta_jubilacion))
      
      # Se calculan los porcentajes de pensión
      
      matriz_porcentajes_jubilacion <-apply(X = outer(antiguedades, tiempos_hasta_jubilacion, FUN = "+"), FUN = porcentaje_de_pension, MARGIN = 1)
      
      # Se calculan los costos por jubilacion
      
      # Matriz con costos por escenario: Personas (columnas) y escenarios (filas)
      
      matriz_costos_jubilacion <- matriz_porcentajes_jubilacion * matriz_salarios_ref_jubilacion * pagos_jubilacion
      
      # Costos por persona: suma por columna de la matriz de costos
      
      if(is.matrix(matriz_costos_jubilacion)){
        costos_jubilacion_por_persona <-apply(X = matriz_costos_jubilacion, MARGIN = 2, FUN = sum)
        }else{
          
          costos_jubilacion_por_persona <- sapply(X = matriz_costos_jubilacion, FUN = sum)
        }
      
      # Suma de los costos de todas las personas
      
      costos_totales_jubilacion <- sum(costos_jubilacion_por_persona)/cant_simulaciones
    }
    
    # RETIRO

    # No es necesario calcular nada ya que no les otorga pensión
    
    # MUERTE
    
    # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por muerte
    
    casos_por_muerte <-extremos_intervalos[,3]<u
    posiciones_muerte <- which(casos_por_muerte, arr.ind = T)
    
    if (identical(posiciones_muerte, integer(0))) {
      costos_totales_muerte <- 0
    } else {
     # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
      
      tiempos_hasta_muerte <- cuantiles[posiciones_muerte]
      
     # Se calculan las anualidades a 10 años correspondientes
      pagos_muerte <- sapply(X=tiempos_hasta_muerte,FUN=valor_anualidad, t=10)/12
      # Se calculan los salarios de referencia en este caso
      
      matriz_salarios_ref_muerte <- mapply(salario_referencia_multiple, antiguedad = antiguedades, salario = salarios, MoreArgs = list(k = tiempos_hasta_muerte))
      
      # Se calculan los porcentajes de pensión
      
      matriz_porcentajes_muerte <-apply(X = outer(antiguedades, tiempos_hasta_muerte, FUN = "+"), FUN = porcentaje_de_pension, MARGIN = 1)
      
      # Se calculan los costos por muerte
      
      # Matriz con costos por escenario: Personas (columnas) y escenarios (filas)
      
      matriz_costos_muerte <- 0.2 * matriz_porcentajes_muerte * matriz_salarios_ref_muerte * pagos_muerte
      
      # Costos por persona: suma por columna de la matriz de costos
      if(is.matrix(matriz_costos_muerte)){
        costos_muerte_por_persona <-apply(X = matriz_costos_muerte, MARGIN = 2, FUN = sum)}
      else{
        costos_muerte_por_persona <- sapply(X = matriz_costos_muerte, FUN = sum)
        
      }
      
      # Suma de los costos de todas las personas
      
      costos_totales_muerte <- sum(costos_muerte_por_persona)/cant_simulaciones
    }
  }
  # RETORNAR LOS COSTOS TOTALES
  costos_totales <- costos_totales_invalidez +
    costos_totales_edad_maxima +
    costos_totales_jubilacion +
    costos_totales_muerte

  return(c(costos_totales_invalidez, costos_totales_jubilacion + costos_totales_edad_maxima, costos_totales_muerte, costos_totales ))
}
```

```{r Verificación equivalencia individual-grupal}
# i <- 1
# cant_simulaciones<-1000
# edad <- afil_mujeres$Edad[i]
# salario <- afil_mujeres$Salario[i]
# antiguedad <-afil_mujeres$Antiguedad[i]
# salarios <- rep(salario, 500)
# antiguedades <- rep(antiguedad, 500)
# edad_maxima <- 77
# lista_tablas_decrementos <- MDListaDeTablasMujeres
# lista_tablas_mortalidad <- ListaDeTablasMujeres
# set.seed(10)
# costo_afiliado_estocastico_grupo_etario(edad, salarios, edad_maxima, antiguedades, cant_simulaciones, lista_tablas_decrementos, lista_tablas_mortalidad)/500
# set.seed(10)
# costo_afiliado_estocastico(edad, salario, edad_maxima, antiguedad, cant_simulaciones, lista_tablas_decrementos, lista_tablas_mortalidad)
```

```{r Prueba estocástico por grupo etario}
# set.seed(10)
# N <- 10000
# t <- proc.time()
# # Costo hombres (Leonardo)
# i<-1
# costos_grupal_estoc_h <- matrix(0, nrow = length(unique(afil_hombres$Edad)), ncol=4)
# for (edad in unique(sort(afil_hombres$Edad))) {
# print(paste("Hombres de ", edad, "años"))
# 
# datos <- afil_hombres %>% filter(Edad == edad) %>% select(Salario, Antiguedad)
# salarios <- datos$Salario
# antiguedades <- datos$Antiguedad
# costos_grupal_estoc_h[i,] <- costo_afiliado_estocastico_grupo_etario(edad, salarios, 85, antiguedades, N, MDListaDeTablasHombres, ListaDeTablasHombres)
# print(costos_grupal_estoc_h[i,4])
# i <- i+1
# }
# proc.time()-t
# costos_grupal_estoc_h <- as.data.frame(costos_grupal_estoc_h)
# colnames(costos_grupal_estoc_h) <- c("Invalidez", "Jubilación", "Muerte", "Total")
# write.csv(costos_grupal_estoc_h,"Costos estocástico hombres por grupo etario.csv", row.names = FALSE)

# Costo mujeres (Joshua)
# 
N <- 10000
costos_grupal_estoc_m <- matrix(NA, nrow = length(unique(afil_mujeres$Edad)), ncol=4)
i<-1
t <- proc.time()
for (edad in unique(sort(afil_mujeres$Edad))) {
print(paste("Mujeres de ", edad, "años"))
datos <- afil_mujeres %>% filter(Edad == edad) %>% select(Salario, Antiguedad)
salarios <- datos$Salario
antiguedades <- datos$Antiguedad
costos_grupal_estoc_m[i,] <- costo_afiliado_estocastico_grupo_etario(edad, salarios, 77, antiguedades, N, MDListaDeTablasMujeres, ListaDeTablasMujeres)
print(costos_grupal_estoc_m[i,4])
i <- i+1
}
proc.time()-t
costos_grupal_estoc_h <- as.data.frame(costos_grupal_estoc_m)
colnames(costos_grupal_estoc_h) <- c("Invalidez", "Jubilación", "Muerte", "Total")
write.csv(costos_grupal_estoc_h,"Costos estocástico mujeres por grupo etario.csv", row.names = FALSE)

```
