---
title: "Proyecto"
author: "Daniel Sabater"
date: '2022-06-05'
output: html_document
---

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
# Programacion hecha por Joshua Cervantes, Moisés Monge y Daniel Sabater
# Se cargan los paquetes
knitr::opts_chunk$set(echo = FALSE)
options(scipen = 999)
library(lifecontingencies)
library(tidyverse)
library(lubridate)
library(readxl)
library(kableExtra)
library(xtable)
library(stringr)
library(magrittr) # uso de %<>% con funciones de dplyr


# Para paralelizar
library(future.apply)
plan(multicore)

# Se cargan las bases de datos

Afiliados_31_12_2021 <- read_excel("Planilla_Compañia_31_12_2021.xlsx")
Pensionados_31_12_2021 <- read_excel("Compañia_Pensionados_31_12_2021.xlsx", range = "A1:F5006")


# Tablas de decrementos

TablasDecrementosHombres <- read_excel("Tablas de decrementos.xlsx",
  sheet = "Hombres"
)
TablasDecrementosMujeres <- read_excel("Tablas de decrementos.xlsx",
  sheet = "Mujeres"
)


# Tablas de mortalidad dinámicas


TablaDinamica_lxsHombres <- as.data.frame(read_excel("TablaDinamica-lxs.xlsx",
  sheet = "Hombres"
))
TablaDinamica_lxsMujeres <- as.data.frame(read_excel("TablaDinamica-lxs.xlsx",
  sheet = "Mujeres"
))


# Se genera lista con las tablas actuariales de los hombres

ListaDeTablasHombres <- list()
for (j in 1:(length(TablaDinamica_lxsHombres) - 1)) {
  ListaDeTablasHombres[[j]] <- with(
    TablaDinamica_lxsHombres,
    new(
      "actuarialtable",
      interest = 0.06,
      x = TablaDinamica_lxsHombres[, 1],
      lx = TablaDinamica_lxsHombres[, j + 1],
      name = paste("E", (j - 1), sep = "")
    )
  )
}

names(ListaDeTablasHombres) <- paste("E", seq(0, 115), sep = "")

# Se genera lista con las tablas actuariales de las mujeres

ListaDeTablasMujeres <- list()
for (j in 1:(length(TablaDinamica_lxsMujeres) - 1)) {
  ListaDeTablasMujeres[[j]] <- with(
    TablaDinamica_lxsMujeres,
    new(
      "actuarialtable",
      interest = 0.06,
      x = TablaDinamica_lxsMujeres[, 1],
      lx = TablaDinamica_lxsMujeres[, j + 1],
      name = paste("E", (j - 1), sep = "")
    )
  )
}

names(ListaDeTablasMujeres) <- paste("E", seq(0, 115), sep = "")

# Se establece la fecha de la valuación

dia_de_evaluacion <- as.Date("31/12/2021", format = "%d/%m/%Y")

# Afiliados

# Cálculo de edades afiliados

edad <- floor(time_length(difftime(
  dia_de_evaluacion,
  as.Date(as.POSIXct(Afiliados_31_12_2021$Fecha_nacimiento), "UTC")
), "years"))

# Depuración de la columna 'Fecha_ingreso'

Afiliados_31_12_2021 %<>% mutate(Fecha_ingreso = paste(substr(Fecha_ingreso, 1, 4),
  "/", substr(Fecha_ingreso, 5, 6), "/", substr(Fecha_ingreso, 7, 8),
  sep = ""
))

# Depuración de la columna 'Fecha_nacimiento'

Afiliados_31_12_2021 %<>% mutate(Fecha_nacimiento = format(Fecha_nacimiento, "%Y/%m/%d"))

# Cálculo de antigüedad

antiguedad <- floor(time_length(difftime(
  dia_de_evaluacion,
  as.Date(
    Afiliados_31_12_2021$Fecha_ingreso,
    "%Y/%m/%d"
  )
), "years"))

# Inclusión de las variables de edad y antigüedad en la base de datos

Afiliados_31_12_2021 %<>% mutate("Edad" = edad, "Antiguedad" = antiguedad)

# Se calcula edad de los pensionados

Pensionados_31_12_2021 %<>% mutate(FEC_NAC = paste(substr(FEC_NAC, 1, 4),
  "/", substr(FEC_NAC, 5, 6), "/", substr(FEC_NAC, 7, 8),
  sep = ""
))

Pensionados_31_12_2021 %<>% mutate(FEC_RIG_PEN = paste(substr(FEC_RIG_PEN, 1, 4),
  "/", substr(FEC_RIG_PEN, 5, 6), "/", substr(FEC_RIG_PEN, 7, 8),
  sep = ""
))

edad <- floor(time_length(
  difftime(
    dia_de_evaluacion,
    as.Date(
      Pensionados_31_12_2021$FEC_NAC,
      "%Y/%m/%d"
    )
  ),
  "years"
))

tiempo_pension <- floor(time_length(
  difftime(
    dia_de_evaluacion,
    as.Date(
      Pensionados_31_12_2021$FEC_RIG_PEN,
      "%Y/%m/%d"
    )
  ),
  "years"
))

Pensionados_31_12_2021 %<>% mutate("Edad" = edad, "T_Pension" = tiempo_pension)

# se crean bases de datos según genero

afil_hombres <- Afiliados_31_12_2021 %>% filter(Sexo == "M")
pen_hombres <- Pensionados_31_12_2021 %>% filter(SEX == "M")
afil_mujeres <- Afiliados_31_12_2021 %>% filter(Sexo == "F")
pen_mujeres <- Pensionados_31_12_2021 %>% filter(SEX == "F")

# Inflacion
inflacion <- 0.04

# Aumentos real
aumento_real <- 0.0150

# Porcentaje de aporte
porcentaje_aporte <- 0.015

# Interes
interes <- 0.07
```

## Tablas de multiples decrementos


```{r message=FALSE, warning=FALSE}

ProMuerte <- function(q1, q2, q3, q4) {
  a <- q1 * ((-3 * q2 * q3 * q4) / 12 + 4 * (q2 * q3 + q3 * q4 + q4 * q2) / 12 - 6 * (q2 + q3 + q4) / 12 + 1)
  b <- q2 * ((-3 * q1 * q3 * q4) / 12 + 4 * (q1 * q3 + q3 * q4 + q4 * q1) / 12 - 6 * (q1 + q3 + q4) / 12 + 1)
  c <- q3 * ((-3 * q2 * q1 * q4) / 12 + 4 * (q2 * q1 + q1 * q4 + q4 * q2) / 12 - 6 * (q2 + q1 + q4) / 12 + 1)
  d <- q4 * ((-3 * q2 * q3 * q1) / 12 + 4 * (q2 * q3 + q3 * q1 + q1 * q2) / 12 - 6 * (q2 + q3 + q1) / 12 + 1)
  qx <- (a + b + c + d)

  return(data.frame("qx1" = a, "qx2" = b, "qx3" = c, "qx4" = d, "qxC" = qx))
}

# Se genera lista con las tablas de multiples decrementos de los hombres

MDListaDeTablasHombres <- list()
for (m in 1:116) {
  qxs <- ProMuerte(TablasDecrementosHombres$Invalidez, TablasDecrementosHombres$Jubilacion, TablasDecrementosHombres$Retiro, qxt(ListaDeTablasHombres[[m]], 0:115, 1))

  Tabladevida <- as.data.frame(qxs)

  Tabladevida$lx <- (1000000:(1000000 - 115))

  for (i in 1:115) {
    Tabladevida$lx[i + 1] <- Tabladevida$lx[i] - Tabladevida$lx[i] * Tabladevida$qxC[i]
  }

  Tabladevida$d1 <- Tabladevida$lx * Tabladevida$qx1
  Tabladevida$d2 <- Tabladevida$lx * Tabladevida$qx2
  Tabladevida$d3 <- Tabladevida$lx * Tabladevida$qx3
  Tabladevida$d4 <- Tabladevida$lx * Tabladevida$qx4

  Tabladevida$d4[1] + Tabladevida$lx[2]

  MDListaDeTablasHombres[[m]] <-
    new(
      "mdt",
      table = Tabladevida[, 7:10],
      name = paste("E", (m - 1), sep = "")
    )
}

names(MDListaDeTablasHombres) <- paste("E", seq(0, 115), sep = "")



# Se genera lista con las tablas de multiples decrementos de las mujeres

MDListaDeTablasMujeres <- list()
for (m in 1:116) {
  qxs <- ProMuerte(TablasDecrementosMujeres$Invalidez, TablasDecrementosMujeres$Jubilacion, TablasDecrementosMujeres$Retiro, qxt(ListaDeTablasMujeres[[m]], 0, c(1:116)))

  Tabladevida <- as.data.frame(qxs)

  Tabladevida$lx <- (1000000:(1000000 - 115))

  for (i in 1:115) {
    Tabladevida$lx[i + 1] <- Tabladevida$lx[i] - Tabladevida$lx[i] * Tabladevida$qxC[i]
  }

  Tabladevida$d1 <- Tabladevida$lx * Tabladevida$qx1
  Tabladevida$d2 <- Tabladevida$lx * Tabladevida$qx2
  Tabladevida$d3 <- Tabladevida$lx * Tabladevida$qx3
  Tabladevida$d4 <- Tabladevida$lx * Tabladevida$qx4

  Tabladevida$d4[1] + Tabladevida$lx[2]

  MDListaDeTablasMujeres[[m]] <-
    new(
      "mdt",
      table = Tabladevida[, 7:10],
      name = paste("E", (m - 1), sep = "")
    )
}

names(MDListaDeTablasMujeres) <- paste("E", seq(0, 115), sep = "")

rm(qxs)
```

Las tablas de decrementos constituyen
 Decremento 1: invalidez
 Decremento 2: jubilación
 Decremento 3: retiro
 Decremento 4: muerte

 
 
# Funciones que nos sirven a todos


```{r}
# porcentaje de pensión
porcentaje_de_pension <- function(antiguedad) {
  
  porcebtajeVejez <- c((antiguedad >= 5 & antiguedad < 10) * 0.10 +
                         (antiguedad >= 10 & antiguedad < 15) * 0.15 +
                         (antiguedad >= 15 & antiguedad < 20) * 0.20 +
                         (antiguedad >= 20 & antiguedad < 25) * 0.25 +
                         (antiguedad >= 25 & antiguedad < 30) * 0.30 +
                         (antiguedad >= 30 & antiguedad < 35) * 0.35 +
                         (antiguedad >= 35) * 0.4)
  
return(porcebtajeVejez)
}


beneficio <- function(antiguedad, decremento, salario, k) {
  antiguedad<-antiguedad+k
  #invalidez
  if (decremento==1 ) {
    porcentaje_de_salario<-porcentaje_de_pension(antiguedad)*0.6
  #vejez
  }else if(decremento==2){
    porcentaje_de_salario<-porcentaje_de_pension(antiguedad)
  #muerte
  }else if(decremento==4){
    porcentaje_de_salario<-porcentaje_de_pension(antiguedad)*0.2
  }
  return(salario_referencia(antiguedad-k, salario, k)*porcentaje_de_salario) 
}


RebajoFondosInsuficientes <- function(MontodePension) {
  MontoRebajado <- c(
    MontodePension * 0.10 +
      (MontodePension >= 2293400) * 0.35 * MontodePension +
      (MontodePension >= 2866750) * 0.45 * MontodePension +
      (MontodePension >= 3583437.50) * 0.55 * MontodePension +
      (MontodePension >= 4479296.88) * 0.65 * MontodePension
  )
  if (MontoRebajado > MontodePension * 0.55) {
    return(MontodePension * 0.55)
  }
  return(MontoRebajado)
}
```










# Estocástico

Las funciones del modelo estocástico no fueron ejecutadas para el HTML, pero se pueden ver los resultados
obtenidos, en tres archivos que son Costos estocástico hombres por grupo etario.csv, 
Costos estocástico mujeres por grupo etario.csv y output.txt (pensiones en curso de pago).

## Personal activo

Primero, se programa una función que calcula el salario de referencia para el cálculo de la pensión para una persona de edad $x$ empleada activa de la compañía dados:

-`antiguedad`: antigüedad a la edad $x$

-`salario`: salario a la edad $x$

-`k`: cantidad de **años** tras los cuáles la persona sufre algún decremento durante la vida laboral, es decir, a la edad $x+k$. Debe cumplir $k\leq 85 -x$ si la persona es hombre o $k\leq 77-x$ si la persona es mujer. 

-`n`: cantidad de salarios anuales promediados para calcular el salario de referencia

Esta función se utiliza en el algortimo de Bacinello (1986) para calcular el salario de referencia una vez simulado que ocurre un decremeno en $k$ años.

```{r Funciones para calcular salarios de referencia, eval = FALSE}

salario_referencia <- function(antiguedad, salario, k, n=5){
  
  # k es el tiempo hasta que ocurre un decremento o se llega a la edad máxima de jubilación

  t <- max(-antiguedad, k - (n-1)):k

  s <- (length(t) - 1):0

  salario_ref <- mean((1.025)^t * (1.04)^(t + s)) * 12 * salario  

  return(salario_ref)
}

salario_referencia_multiple <- function(antiguedad, salario, k) {
  return(sapply(X = k, FUN = salario_referencia, antiguedad = antiguedad, salario = salario))
}
```

Por ejemplo, si una persona de edad $50$ sufre algún decremento $2$ años despúes y tenía a la edad $50$ una antiguedad de $10$ años, entonces el salario de referencia, suponiendo un salario actual de $900,000$ para el cálculo de su pensión es

```{r Ejemplo funcionalidad salario_referencia}

salario_referencia(10, 900000, 2)
```

En segundo lugar, se crea una función que, dado un vector con la distribución de una variable aleatoria discreta $X$ que toma valores en un subconjunto finito de $\mathbb{N}\cup\{0\}$, es decir, un vector de la forma
\[
\bigg( \mathbb{P}(X=0),\mathbb{P}(X\leq 1), \mathbb{P}(X\leq 2),\mathbb{P}(X\leq 3),\dots\bigg),
\]
así como un número $0<p<1$, entonces retorna un valor $k\in\{0,1,2,\dots\}$ tal que

\[
\mathbb{P}(X\leq k-1)<p\leq \mathbb{P}(X\leq k),
\]

que corresponde al $p$-cuantil de $X$. Esta función se utiliza en el algortimo de Bacinello (1986) para hallar el momento de ocurrencia de algún decremento bajo el segundo criterio que plantea dicho método. Recibe los parámetros

-`distribucion`: vector con los valores de la función de distribución

-`p`: probabilidad de la cual se quiere calcular el cuantil

```{r Función para localizar cuantiles en modelo estocástico, eval = FALSE
}

hallar_cuantil <- function(distribucion, p) {
  if(p>max(distribucion)){k <- length(distribucion)-1}
  else{
  k <- min(which(p <= distribucion, arr.ind = TRUE))-1
  }
  return(k)
}
```

#### Ejemplo

```{r, echo=F, eval = FALSE
}

set.seed(8000) 
```

Se presenta un ejemplo para hallar el cuantil correspondiente a una muestra uniforme en (0,1) `r runif(1)` con la distribución de $W_{30}$. Se verifica gráficamente el desempeño adecuado de la función. Observe que el valor retornado debe ser el menor valor de $k$ tal que $F_{W_{30}}(k)\geq u$

```{r}

# Edad
x <- 30
xi <- 85
# Distribución
FWx <- qxt(MDListaDeTablasHombres[[x + 1]], x = x, t = 1:(xi-x))
# Uniforme(0,1)
set.seed(8000)
(u <- runif(1))
(k <- hallar_cuantil(FWx, u))
plot(0:(xi-x-1), FWx) + abline(h = u, col="red") + abline(v = k, col="red")
```

En el modelo estocástico para las personas afiliadas, será necesario calcular el valor de la pensión sabiendo que ocurre un decremento $k$ años después, a la edad $x+k$ y que, además, la persona vive hasta la edad $x+k+t$. Por ello, se programa la función `valor_anualidad`, que recibe los parámetros:

-`k`: años tras los cuáles ocurre un decremento

-`t`: años residuales de vida después de sufrido el decremento

La msima retorna un número, que corresponde al valor de la anualidad, suponiendo pagos mensuales de una unidad actualizados anualmente por inflación.

```{r Función anualidad para modelo estocástico, eval = FALSE
}

# Se crea una función para calcular el monto de los beneficios si ocurre un decremento tras k años y la persona vive t años adicionales
valor_anualidad <- function(k, t, v=1/1.07) {
    if(t==0){t=1}
    vectorMensual <- seq(1 / 12, t, 1 / 12)
    vectoraguinaldo <-c(rep(0, 10), 1, 0)
    vectorAnualmensual <- sort(rep(c(0:(t-1)), 12))
    MontoAPagar <- (1 + 0.04)^(vectorAnualmensual) * 2^vectoraguinaldo
    anualidad <- (v)^(vectorMensual)
    suma1 <- sum(anualidad * MontoAPagar)
    PV_aux <- suma1 * v^(k + 1)
    return(PV_aux)
}
```

Para calcular los costos asociados a las personas afiliadas al plan ofrecido por la Compañía, se implementa una modificación de uno de los algortimos descritos en Bacinello (1988) bajo un modelo de múltiples decrementos. El mencionado algoritmo permite simular la variable aleatoria $W_{x}$ del tiempo (en años) de trabajo residual de un empleado activo de edad $(x)$. En esencia, el método proporciona un criterio para, en un primer paso y dada una muestra de una distribución $\mathcal{U}(0,1)$, decidir si una persona de edad $(x)$ se llega a jubilar por llegar a la edad máxima de jubilación, en cuyo caso resta solamente simular su tiempo de vida residual. En su defecto, el algoritmo proporciona una regla para asignar, de acuerdo a una segunda muestra de una distribución $\mathcal{U}(0,1)$, cuál de los decrementos restantes sucedió para que no se llegara a la edad máxima de jubilación. Como puede comprobarse, el método requiere a lo sumo dos muestras provenientes de una distribución $\mathcal{U}(0,1)$ en aras de obtener una muestra de $W_{x}$.

Se programa primero la función `costo_afiliado_estocastico`, que recibe los parámetros:

-`edad`: edad actual de la persona

-`salario`: salario actual

-`edad_maxima`: edad máxima de jubilación. Es 77 si la persona es mujer y 85 si es hombre.

-`antiguedad`: antigüedad actual de la persona en la Compañía (cantidad de años laborados en la Compañía a la fecha)

-`cant_simulaciones`: Cantidad de simulaciones a usar

-`lista_tablas_decrementos`: Objeto de tipo lista que contiene las tablas de múltiples decrementos para cada edad, es decir, es una lista de objetos tipo "mdt"

-`lista_tablas_mortalidad`: Objeto de tipo lista que contiene las tablas de múltiples decrementos para cada edad, es decir, una lista de objetos tipo "actuarialtable"

Asimismo, esta función retorna un vector de cuatro entradas, correspondiente al cálculo del costo para el plan de la Compañía asociado a esta persona de acuerdo al método estocástico según, en orden los riesgos de invalidez, jubilación y muerte, teniendo por cuarta entrada la suma de las anteriores.

### Versión con simulación individual

```{r Modelo estocástico individual, eval = FALSE
}

costo_afiliado_estocastico <- function(edad, salario, edad_maxima, antiguedad, cant_simulaciones, lista_tablas_decrementos, lista_tablas_mortalidad) {
  x <- edad
  xi <- edad_maxima
  q4_prima <- lista_tablas_mortalidad[[x + 1]]
  # Se define la distribución del modelo de múltiples decrementos (todas las causas)
  FWx <- qxt(lista_tablas_decrementos[[x + 1]], x = x, t = 1:(xi-x))
  # Se toman muestras uniformes en (0,1) según se especificó
  u <- runif(cant_simulaciones)  
  # PRIMER CRITERIO: Jubilación obligatoria
  # Se cuenta la cantidad escenarios en que ocurrió esta condición: Se comprueba u>FWx(xi-x-1) (se tiene que correr el índice)
  cant_pensiones_edad_maxima <- length(u[u > FWx[xi-x]])
  if(cant_pensiones_edad_maxima==0){
    costos_edad_maxima <- 0
  }else{
    # Se calcula el salario de referencia en este caso
    salario_ref_edad_maxima <- salario_referencia(antiguedad, salario, xi-x)
    # Se simulan los tiempos residuales de vida (en años) para los pensionados de edad máxima (xi)
    tiempos_residuales_edad_maxima <- rLife(n=cant_pensiones_edad_maxima, object = q4_prima, x=xi+1, k = 1, type = "curtate")
    # Se calculan las anualidades mensuales
    pagos_edad_maxima <- sapply(X=tiempos_residuales_edad_maxima, FUN=valor_anualidad, k=xi-x)/12 
    # Se calculan los costos asociados al primer criterio del algoritmo
    costos_edad_maxima <- salario_ref_edad_maxima * pagos_edad_maxima
  }
  # SEGUNDO CRITERIO: Decremento antes de jubilación por edad máxima
  if(cant_pensiones_edad_maxima<cant_simulaciones){# esta condición significa que hay otros escenarios
      # Debe determinarse cuándo ocurrió el decremento y cuál fue
    # Primero se determina cuándo ocurrió, es decir, se buscan los cuantiles de la distribución de Wx que corresponden a las simulaciones U(0,1) restantes
    cuantiles <- lapply(X = u[u <= FWx[xi-x]], FUN = hallar_cuantil, distribucion = FWx) %>% unlist() 
    # Se calculan las probabilidades condicionales al momento de ocurrencia del decremento
    # Se calculan las probabilidades condicionales al momento de ocurrencia del decremento
    # Primero, se determinan los numeradores
    numeradores <- cbind(
    qxt(lista_tablas_decrementos[[x + 1]], x = x+cuantiles, t = 1, decrement = 1),
    qxt(lista_tablas_decrementos[[x + 1]], x = x+cuantiles, t = 1, decrement = 2),
    qxt(lista_tablas_decrementos[[x + 1]], x = x+cuantiles, t = 1, decrement = 3),
    qxt(lista_tablas_decrementos[[x + 1]], x = x+cuantiles, t = 1, decrement = 4)
  )
    # Segundo, se determinan los denominadores
    denominadores <- apply(X = numeradores, MARGIN = 1, FUN=sum) %>% unlist()
    denominadores[denominadores==0] <- 1 # Para evitar indefiniciones
    # Tercero, se determinan las probabilidades condicionales dividiendo cada fila (numerador) entre el denominador respectivo
    probs_condicionales <- sweep(x=numeradores, MARGIN = 1, STATS = denominadores, FUN = '/' )
    
    # Se determinan los escenarios en que ocurrió cada decremento
    
    # Primero, se tienen que simular nuevas muestras U(0,1) para los casos que no fueron incluidos en el primer criterio
    u <- runif(cant_simulaciones-cant_pensiones_edad_maxima)
    # Se determinan los extramemos de los intervalos de decisión
    extremos_intervalos <- apply(X = probs_condicionales, MARGIN = 1, FUN = cumsum) %>% t()
    
    # INVALIDEZ
    # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por invalidez
    casos_por_invalidez <- u<=extremos_intervalos[,1]
    posiciones_invalidez <- which(casos_por_invalidez , arr.ind = T)
    if(identical(posiciones_invalidez, integer(0))){
      costos_invalidez <- 0
    }else{
      # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
      tiempos_hasta_invalidez <- cuantiles[posiciones_invalidez]
      # Se simulan los tiempos residuales de vida
      tiempos_residuales_invalidez <- lapply(X = x+tiempos_hasta_invalidez+1, FUN = rLife, n=1, object = q4_prima, k = 1, type = "curtate") %>% unlist()
      
      # Se calculan las anualidades correspondientes
      pagos_invalidez <- mapply(FUN=valor_anualidad, k=tiempos_hasta_invalidez, t=tiempos_residuales_invalidez)/12
      
      # Se calculan los salarios de referencia en este caso
      salarios_ref_invalidez <- lapply(X=tiempos_hasta_invalidez, FUN = salario_referencia, antiguedad=antiguedad, salario=salario) %>% unlist()
      # Se calculan los porcentajes de pensión
      porcentajes_invalidez <- lapply(X=antiguedad+tiempos_hasta_invalidez, FUN=porcentaje_de_pension) %>% unlist()
      # Se calculan los costos por invalidez
      costos_invalidez <- 0.6 * porcentajes_invalidez * salarios_ref_invalidez * pagos_invalidez
    }
    # JUBILACIÓN
    
    # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por jubilación
    casos_por_jubilacion <- extremos_intervalos[,1]<u & u <=extremos_intervalos[,2]
    posiciones_jubilacion <- which(casos_por_jubilacion, arr.ind = T)

    if(identical(posiciones_jubilacion, integer(0))){
      costos_jubilacion <- 0
    }else{
      # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
      tiempos_hasta_jubilacion <- cuantiles[posiciones_jubilacion] 
      
      # Se simulan los tiempos residuales de vida
      tiempos_residuales_jubilacion <- lapply(X = x+tiempos_hasta_jubilacion+1, FUN = rLife, n=1, object = q4_prima, k = 1, type = "curtate") %>% unlist()
      # Se calculan las anualidades correspondientes
      pagos_jubilacion <- mapply(FUN=valor_anualidad, k=tiempos_hasta_jubilacion, t=tiempos_residuales_jubilacion)/12
      # Se calculan los salarios de referencia en este caso
      salarios_ref_jubilacion <- lapply(X=tiempos_hasta_jubilacion, FUN = salario_referencia, antiguedad=antiguedad, salario=salario) %>% unlist()
      # Se calculan los porcentajes de pensión
      porcentajes_jubilacion <- lapply(X=antiguedad+tiempos_hasta_jubilacion, FUN=porcentaje_de_pension) %>% unlist()
      # Se calculan los costos por jubilacion
      costos_jubilacion <- porcentajes_jubilacion * salarios_ref_jubilacion*pagos_jubilacion
      
    }
    
    # RETIRO
    # casos_por_retiro <- extremos_intervalos[,2]<u & u<=extremos_intervalos[,3]
    # No es necesario calcular nada ya que no les otorga pensión
    
    # MUERTE
    
    # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por muerte
    casos_por_muerte <-extremos_intervalos[,3]<u
    posiciones_muerte <- which(casos_por_muerte, arr.ind = T)
    
    if(identical( posiciones_muerte, integer(0))){
      tiempos_hasta_muerte<-0
    }else{
      # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
      tiempos_hasta_muerte <- cuantiles[posiciones_muerte] 
      # Se calculan las anualidades a 10 años correspondientes
      pagos_muerte <- sapply(X=tiempos_hasta_muerte,FUN=valor_anualidad, t=10)/12
      # Se calculan los salarios de referencia en este caso
      salarios_ref_muerte <- lapply(X=tiempos_hasta_muerte, FUN = salario_referencia, antiguedad=antiguedad, salario=salario) %>% unlist()
      # Se calculan los porcentajes de pensión
      porcentajes_muerte <- lapply(X=antiguedad+tiempos_hasta_muerte, FUN=porcentaje_de_pension) %>% unlist()
      # Se calculan los costos por muerte
      costos_muerte <- 0.2 * porcentajes_muerte * salarios_ref_muerte * pagos_muerte
      
    }
    
  }
  costos_totales_invalidez <- sum(costos_invalidez)/cant_simulaciones
  costos_totales_jubilacion <- sum(costos_jubilacion, costos_edad_maxima)/cant_simulaciones
  costos_totales_muerte <- sum(costos_muerte)/cant_simulaciones
  costos <- c(costos_totales_invalidez, costos_totales_jubilacion, costos_totales_muerte,costos_totales_invalidez+costos_totales_jubilacion+costos_totales_muerte )
    return(costos)
  }

```

#### Ejemplo

Se calcula una simulación con la primera mujer de la tabla y 100 simulaciones.

```{r Ejemplo del uso de la función, eval = FALSE
}

i <- 1
cant_simulaciones<-100
edad <- afil_mujeres$Edad[i]
edad_maxima <- 77
salario <- afil_mujeres$Salario[i]
antiguedad <-afil_mujeres$Antiguedad[i]
lista_tablas_decrementos <- MDListaDeTablasMujeres
lista_tablas_mortalidad <- ListaDeTablasMujeres
set.seed(10)
comma(costo_afiliado_estocastico(edad, salario, edad_maxima, antiguedad, cant_simulaciones, lista_tablas_decrementos, lista_tablas_mortalidad))
```



### Versión con simulación por grupos de edad


Para calcular los costos asociados a las personas afiliadas al plan ofrecido por la Compañía, se implementa una modificación de uno de los algortimos descritos en Bacinello (1988) bajo un modelo de múltiples decrementos. El mencionado algoritmo permite simular la variable aleatoria $W_{x}$ del tiempo (en años) de trabajo residual de un empleado activo de edad $(x)$. En esencia, el método proporciona un criterio para, en un primer paso y dada una muestra de una distribución $\mathcal{U}(0,1)$, decidir si una persona de edad $(x)$ se llega a jubilar por llegar a la edad máxima de jubilación, en cuyo caso resta solamente simular su tiempo de vida residual. En su defecto, el algoritmo proporciona una regla para asignar, de acuerdo a una segunda muestra de una distribución $\mathcal{U}(0,1)$, cuál de los decrementos restantes sucedió para que no se llegara a la edad máxima de jubilación. Como puede comprobarse, el método requiere a lo sumo dos muestras provenientes de una distribución $\mathcal{U}(0,1)$ en aras de obtener una muestra de $W_{x}$.

Se programa primero la función `costo_afiliado_estocastico_grupo_etario`, que recibe los parámetros

-`edad`: edad actual de la persona

-`salarios`: vector de salarios actuales del grupo

-`edad_maxima`: edad máxima de jubilación. Es 77 si la persona es mujer y 85 si es hombre

-`antiguedades`: vector de antigüedades actuales de la personas del grupo

-`cant_simulaciones`: Cantidad de simulaciones a usar

-`lista_tablas_decrementos`: Objeto de tipo lista que contiene las tablas de múltiples decrementos para cada
edad, es decir, es una lista de objetos tipo "mdt".

-`lista_tablas_mortalidad`: Objeto de tipo lista que contiene las tablas de múltiples decrementos para cada edad, es decir, una lista de objetos tipo "actuarialtable".

Asimismo, esta función retorna un vector de cuatro entradas, correspondiente al cálculo del costo para el plan de la Compañía asociado a al grupo de una misma edad de acuerdo al método estocástico según, en orden, los riesgos de invalidez, jubilación y muerte, teniendo por cuarta entrada la suma de las anteriores.


```{r Modelo estocástico por grupos de edad, eval = FALSE
}

costo_afiliado_estocastico_grupo_etario <- function(edad, salarios, edad_maxima, antiguedades, cant_simulaciones, lista_tablas_decrementos, lista_tablas_mortalidad) {
  x <- edad
  xi <- edad_maxima
  q4_prima <- lista_tablas_mortalidad[[x + 1]]
  # Se define la distribución del modelo de múltiples decrementos (todas las causas)
  FWx <- qxt(lista_tablas_decrementos[[x + 1]], x = x, t = 1:(xi-x))
  # Se toman muestras uniformes en (0,1) según se especificó
  u <- runif(cant_simulaciones)
  # PRIMER CRITERIO
  # Cantidad de casos del primer criterio
  cant_pensiones_edad_maxima <- length(u[u > FWx[xi-x]])
  if (cant_pensiones_edad_maxima == 0) {
    costos_totales_edad_maxima <- 0
  } else {
    # Se simulan los tiempos residuales de vida (en años) para los pensionados de edad máxima (xi)
    tiempos_residuales_edad_maxima <- rLife(n = cant_pensiones_edad_maxima, object = q4_prima, x = xi+1, k = 1, type = "curtate")
    # Se calculan las anualidades mensuales
    pagos_edad_maxima <- sapply(X=tiempos_residuales_edad_maxima, FUN=valor_anualidad, k=xi-x)/12
    # Se calcula la matriz de salarios
    matriz_salarios_ref_edad_maxima <- mapply(salario_referencia_multiple, antiguedad = antiguedades, salario = salarios, MoreArgs = list(k = rep(xi-x, cant_pensiones_edad_maxima)))
    
    # Se calculan los porcentajes de pensión
    matriz_porcentajes_edad_maxima <- apply(X = outer(antiguedades, rep(xi - x, length(cant_pensiones_edad_maxima)), FUN = "+"), FUN = porcentaje_de_pension, MARGIN = 1)
    
    # Se calculan los costos por edad_maxima
    
    # Matriz con costos por escenario: Personas (columnas) y escenarios (filas)
    
    matriz_costos_edad_maxima <- matriz_porcentajes_edad_maxima * matriz_salarios_ref_edad_maxima * pagos_edad_maxima
    
    # Costos por persona: suma por columna de la matriz de costos
    if(is.matrix(matriz_costos_edad_maxima )){
    costos_edad_maxima_por_persona <-apply(X = matriz_costos_edad_maxima, MARGIN = 2, FUN = sum)
    }else{
      costos_edad_maxima_por_persona <- sapply(X = matriz_costos_edad_maxima, FUN = sum)
    }
    # Suma de los costos de todas las personas
    costos_totales_edad_maxima <- sum(costos_edad_maxima_por_persona)/cant_simulaciones
  }
  # SEGUNDO CRITERIO: Decremento antes de jubilación
  if (cant_pensiones_edad_maxima < cant_simulaciones) { # esta condición significa que hay otros escenarios
    
    # Debe determinarse cuándo ocurrió el decremento y cuál fue
    # Primero se determina cuándo ocurrió, es decir, se buscan los cuantiles de la distribución de Wx que corresponden a las simulaciones U(0,1) restantes
    cuantiles <- lapply(X = u[u <= FWx[xi-x]], FUN = hallar_cuantil, distribucion = FWx) %>% unlist()
    # Se calculan las probabilidades condicionales al momento de ocurrencia del decremento
    # Primero, se determinan los numeradores
    numeradores <- cbind(
    qxt(lista_tablas_decrementos[[x + 1]], x = x+cuantiles, t = 1, decrement = 1),
    qxt(lista_tablas_decrementos[[x + 1]], x = x+cuantiles, t = 1, decrement = 2),
    qxt(lista_tablas_decrementos[[x + 1]], x = x+cuantiles, t = 1, decrement = 3),
    qxt(lista_tablas_decrementos[[x + 1]], x = x+cuantiles, t = 1, decrement = 4)
  )
    # Segundo, se determinan los denominadores
    denominadores <-apply(X = numeradores, MARGIN = 1, FUN = sum) %>% unlist()
    denominadores[denominadores == 0] <- 1 # esto se hace para evitar indefiniciones
    # Tercero, se determinan las probabilidades condicionales dividiendo cada fila (numerador) entre el denominador respectivo
    probs_condicionales <- sweep(x = numeradores, MARGIN = 1, STATS = denominadores, FUN = "/")
    
    # Se determinan los escenarios en que ocurrió cada decremento
    
    # Primero, se tienen que simular nuevas muestras U(0,1) para los casos que no fueron incluidos en el primer criterio
    u <- runif(cant_simulaciones - cant_pensiones_edad_maxima)
    # Se determinan los extramemos de los intervalos de decisión
    extremos_intervalos <- apply(X = probs_condicionales, MARGIN = 1, FUN = cumsum) %>% t()
    
    
    # INVALIDEZ
    
     # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por invalidez
    casos_por_invalidez <- u<=extremos_intervalos[,1]
    posiciones_invalidez <- which(casos_por_invalidez , arr.ind = T)

    if (identical(posiciones_invalidez, integer(0))) {
      costos_totales_invalidez <- 0
    } else {
      # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
      tiempos_hasta_invalidez <- cuantiles[posiciones_invalidez]
      # Se simulan los tiempos residuales de vida
      tiempos_residuales_invalidez <- lapply(X = x + tiempos_hasta_invalidez+1, FUN = rLife, n = 1, object = q4_prima, k = 1, type = "curtate") %>% unlist()
      
      # Se calculan las anualidades correspondientes
     
       pagos_invalidez <- mapply(FUN=valor_anualidad, k=tiempos_hasta_invalidez, t=tiempos_residuales_invalidez)/12
      
      # Se calculan los salarios de referencia en este caso
      
      matriz_salarios_ref_invalidez <- mapply(salario_referencia_multiple, antiguedad = antiguedades, salario = salarios, MoreArgs = list(k = tiempos_hasta_invalidez))
      
      # Se calculan los porcentajes de pensión
      
      matriz_porcentajes_invalidez <-apply(X = outer(antiguedades, tiempos_hasta_invalidez, FUN = "+"), FUN = porcentaje_de_pension, MARGIN = 1)
      
      # Se calculan los costos por invalidez
      
      # Matriz con costos por escenario: Personas (columnas) y escenarios (filas)
      
      matriz_costos_invalidez <- 0.6 * matriz_porcentajes_invalidez * matriz_salarios_ref_invalidez * pagos_invalidez
      
      # Costos por persona: suma por columna de la matriz de costos
      
      if(is.matrix(matriz_costos_invalidez)){
        costos_invalidez_por_persona <-apply(X = matriz_costos_invalidez, MARGIN = 2, FUN = sum)
      }else{
        costos_invalidez_por_persona <- sapply(X = matriz_costos_invalidez, FUN = sum)
      }
      
      # Suma de los costos de todas las personas
      
      costos_totales_invalidez <- sum(costos_invalidez_por_persona)/cant_simulaciones
    }
    # JUBILACIÓN
    
    # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por jubilación
    
        casos_por_jubilacion <- extremos_intervalos[,1]<u & u<=extremos_intervalos[,2]
    posiciones_jubilacion <- which(casos_por_jubilacion, arr.ind = T)

    if (identical(posiciones_jubilacion, integer(0))) {
      costos_totales_jubilacion <- 0
    } else {
      # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
      tiempos_hasta_jubilacion <- cuantiles[posiciones_jubilacion]
      
      # Se simulan los tiempos residuales de vida
      tiempos_residuales_jubilacion <- lapply(X = x + tiempos_hasta_jubilacion+1, FUN = rLife, n = 1, object = q4_prima, k = 1, type = "curtate") %>% unlist()
      
      # Se calculan las anualidades correspondientes
      pagos_jubilacion <- mapply(FUN=valor_anualidad, k=tiempos_hasta_jubilacion, t=tiempos_residuales_jubilacion)/12
      # Se calculan los salarios de referencia en este caso
      
      matriz_salarios_ref_jubilacion <- mapply(salario_referencia_multiple, antiguedad = antiguedades, salario = salarios, MoreArgs = list(k = tiempos_hasta_jubilacion))
      
      # Se calculan los porcentajes de pensión
      
      matriz_porcentajes_jubilacion <-apply(X = outer(antiguedades, tiempos_hasta_jubilacion, FUN = "+"), FUN = porcentaje_de_pension, MARGIN = 1)
      
      # Se calculan los costos por jubilacion
      
      # Matriz con costos por escenario: Personas (columnas) y escenarios (filas)
      
      matriz_costos_jubilacion <- matriz_porcentajes_jubilacion * matriz_salarios_ref_jubilacion * pagos_jubilacion
      
      # Costos por persona: suma por columna de la matriz de costos
      
      if(is.matrix(matriz_costos_jubilacion)){
        costos_jubilacion_por_persona <-apply(X = matriz_costos_jubilacion, MARGIN = 2, FUN = sum)
        }else{
          
          costos_jubilacion_por_persona <- sapply(X = matriz_costos_jubilacion, FUN = sum)
        }
      
      # Suma de los costos de todas las personas
      
      costos_totales_jubilacion <- sum(costos_jubilacion_por_persona)/cant_simulaciones
    }
    
    # RETIRO

    # No es necesario calcular nada ya que no les otorga pensión
    
    # MUERTE
    
    # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por muerte
    
    casos_por_muerte <-extremos_intervalos[,3]<u
    posiciones_muerte <- which(casos_por_muerte, arr.ind = T)
    
    if (identical(posiciones_muerte, integer(0))) {
      costos_totales_muerte <- 0
    } else {
     # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
      
      tiempos_hasta_muerte <- cuantiles[posiciones_muerte]
      
     # Se calculan las anualidades a 10 años correspondientes
      pagos_muerte <- sapply(X=tiempos_hasta_muerte,FUN=valor_anualidad, t=10)/12
      # Se calculan los salarios de referencia en este caso
      
      matriz_salarios_ref_muerte <- mapply(salario_referencia_multiple, antiguedad = antiguedades, salario = salarios, MoreArgs = list(k = tiempos_hasta_muerte))
      
      # Se calculan los porcentajes de pensión
      
      matriz_porcentajes_muerte <-apply(X = outer(antiguedades, tiempos_hasta_muerte, FUN = "+"), FUN = porcentaje_de_pension, MARGIN = 1)
      
      # Se calculan los costos por muerte
      
      # Matriz con costos por escenario: Personas (columnas) y escenarios (filas)
      
      matriz_costos_muerte <- 0.2 * matriz_porcentajes_muerte * matriz_salarios_ref_muerte * pagos_muerte
      
      # Costos por persona: suma por columna de la matriz de costos
      if(is.matrix(matriz_costos_muerte)){
        costos_muerte_por_persona <-apply(X = matriz_costos_muerte, MARGIN = 2, FUN = sum)}
      else{
        costos_muerte_por_persona <- sapply(X = matriz_costos_muerte, FUN = sum)
        
      }
      
      # Suma de los costos de todas las personas
      
      costos_totales_muerte <- sum(costos_muerte_por_persona)/cant_simulaciones
    }
  }
  # RETORNAR LOS COSTOS TOTALES
  costos_totales <- costos_totales_invalidez +
    costos_totales_edad_maxima +
    costos_totales_jubilacion +
    costos_totales_muerte

  return(c(costos_totales_invalidez, costos_totales_jubilacion + costos_totales_edad_maxima, costos_totales_muerte, costos_totales ))
}
```

#### Ejemplo

Se realiza el cálculo para el grupo de mujeres de 46 años con 1000 simulaciones.

```{r, eval = FALSE
}
edad <- 46
datos <- afil_mujeres %>% filter(Edad == edad) %>% select(Salario, Antiguedad)
salarios <- datos$Salario
edad_maxima <- 77
cant_simulaciones <- 1000
antiguedades <- datos$Antiguedad
lista_tablas_decrementos <- MDListaDeTablasMujeres
lista_tablas_mortalidad <- ListaDeTablasMujeres
comma(costo_afiliado_estocastico_grupo_etario(edad, salarios, edad_maxima, antiguedades, cant_simulaciones, lista_tablas_decrementos, lista_tablas_mortalidad))
```

#### Cálculo para el proyecto

Con el siguiente código se calcularon las cifras presentadas en el proyecto. Se muestra el código mas este no se ejecuta, pues tarda alrededor de una hora en terminar.

```{r Prueba estocástico por grupo etario, eval=FALSE}

set.seed(10)
N <- 10000
t <- proc.time()
# Costo hombres
i<-1
costos_grupal_estoc_h <- matrix(0, nrow = length(unique(afil_hombres$Edad)), ncol=4)
for (edad in unique(sort(afil_hombres$Edad))) {
print(paste("Hombres de ", edad, "años"))
datos <- afil_hombres %>% filter(Edad == edad) %>% select(Salario, Antiguedad)
salarios <- datos$Salario
antiguedades <- datos$Antiguedad
costos_grupal_estoc_h[i,] <- costo_afiliado_estocastico_grupo_etario(edad, salarios, 85, antiguedades, N, MDListaDeTablasHombres, ListaDeTablasHombres)
print(costos_grupal_estoc_h[i,4])
i <- i+1
}
proc.time()-t
colnames(costos_grupal_estoc_h) <- c("Invalidez", "Jubilación", "Muerte", "Total")
write.csv(costos_grupal_estoc_h,"Costos estocástico hombres por grupo etario.csv", row.names = FALSE)

comma(apply(X=costos_grupal_estoc_h, MARGIN=2, FUN=sum))
# Costo mujeres 
# 
N <- 10000
costos_grupal_estoc_m <- matrix(NA, nrow = length(unique(afil_mujeres$Edad)), ncol=4)
i<-1
t <- proc.time()
for (edad in unique(sort(afil_mujeres$Edad))) {
print(paste("Mujeres de ", edad, "años"))
datos <- afil_mujeres %>% filter(Edad == edad) %>% select(Salario, Antiguedad)
salarios <- datos$Salario
antiguedades <- datos$Antiguedad
costos_grupal_estoc_m[i,] <- costo_afiliado_estocastico_grupo_etario(edad, salarios, 77, antiguedades, N, MDListaDeTablasMujeres, ListaDeTablasMujeres)
print(costos_grupal_estoc_m[i,4])
i <- i+1
}
proc.time()-t
colnames(costos_grupal_estoc_m) <- c("Invalidez", "Jubilación", "Muerte", "Total")
#Se escribe un csv con los resultados
write.csv(costos_grupal_estoc_m,"Costos estocástico mujeres por grupo etario.csv", row.names = FALSE)

```




### Funcion para determinar pension de personas ya pensionadas

Se ha creado una función para el calculo estocástico de las pensiones en curso de pago llamada `pension_pen`. Recibe los siguiente parámetros:
`base_de_datos` (data.frame): esta es la base de los ya pensionados.
`sex` (boolean): se indica si la base de datos corresponde a la de hombres (`TRUE`) o mujeres (`FALSE`).
`t_descuento` (numeric): tasa utilizada para llevar montos a valor presente.
`m` (numeric): la cantidad de pagos que se relizan al año.
`simulaciones`(numeric): número de simulaciones deseadas.

```{r, eval = FALSE}
pension_pen <- function(base_de_datos, sex, t_descuento, m, simulaciones) {
  v <- 1 / (1 + t_descuento)
  # aumento<-(1+0.03)*(1+aumento_real)
  edades <- base_de_datos$Edad
  montos <- base_de_datos$MON_PEN
  fn2 <- function(edad, monto) {
    # print("Hola")
    Edad <- edad
    suma <- 0
    simulacion <- simulaciones
    # monto<-monto*(v*aumento)^(max(jubilacion-Edad,0)) en este caso si se descomenta se calcula para los ya pensionados
    # monto<-monto
    ajuste <- 1
    j <- 1 / m
    i <- 1
    while (simulacion > 0) {
      if (sex) {
        probabilidad <- pxt(ListaDeTablasHombres[[(Edad + 1)]], x = edad, t = 1 / m)
      } else {
        probabilidad <- pxt(ListaDeTablasMujeres[[(Edad + 1)]], x = edad, t = 1 / m)
      }
      vivos <- sum(rbinom(n = simulacion, size = 1, prob = probabilidad))
      simulacion <- vivos
      edad <- edad + 1 / m
      suma <- suma + v^j * ajuste * vivos * 2^(i == 11)
      ajuste <- ajuste * (1 + inflacion)^(i == 12)
      j <- j + 1 / m
      i <- (1 + i) * (i < 12) + 1 * (i == 12)
    }
    return(monto * suma / simulaciones)
  }
  valores <- unlist(future_mapply(FUN = fn2, edad = edades, monto = montos, SIMPLIFY = FALSE))
  return(sum(valores))
}
```

## Calculo de pension estocastico

```{r, eval = FALSE}
#Resultado de los pensionados
##Mujeres
(pension_pen_m <- pension_pen(pen_mujeres, FALSE, 0.07, 12, 1000))

##Hombres
(pension_pen_h <- pension_pen(pen_hombres, TRUE, 0.07, 12, 1000))

#Se guardan los resultados en un txt
fileConn <- file("output.txt")
writeLines(paste("Estocastico:", "Mujeres", pension_pen_m, "Hombres", pension_pen_h, sep = " "), fileConn)
close(fileConn)
```


# Deterministico


Se presentan las funciones necesarias para otras funciones.

La función `porcentaje_de_pension` retorna el porcentaje de pensión que le correspondería al individuo de acuerdo a la antigüedad, la variables que recibe son las siguientes parámetros:
`antiguedad` (numeric): tiempo que lleva la persona laborando en la empresa.

La función `beneficio` retorna el monto correspondiende de pensión de acuerdo al momento de salida, decremento y antigüedad, recibe:
`antiguedad` (numeric): tiempo que lleva la persona laborando en la empresa.
`decremento` (numeric): es el tipo de decremento por el que salió el individuo.
`salario` (numeric): es el salario actual del individuo.
`k` (numeric): tiempo transcurrido del momento de valoración y momento esperado de saldia.
```{r}
# Porcentaje de pensión
porcentaje_de_pension <- function(antiguedad) {
  porcebtajeVejez <- c((antiguedad >= 5 & antiguedad < 10) * 0.10 +
    (antiguedad >= 10 & antiguedad < 15) * 0.15 +
    (antiguedad >= 15 & antiguedad < 20) * 0.20 +
    (antiguedad >= 20 & antiguedad < 25) * 0.25 +
    (antiguedad >= 25 & antiguedad < 30) * 0.30 +
    (antiguedad >= 30 & antiguedad < 35) * 0.35 +
    (antiguedad >= 35) * 0.4)

  return(porcebtajeVejez)
}


beneficio <- function(antiguedad, decremento, salario, k) {
  antiguedad <- antiguedad + k
  # invalidez
  if (decremento == 1) {
    porcentaje_de_salario <- porcentaje_de_pension(antiguedad) * 0.6
    # vejez
  } else if (decremento == 2) {
    porcentaje_de_salario <- porcentaje_de_pension(antiguedad)
    # muerte
  } else if (decremento == 4) {
    porcentaje_de_salario <- porcentaje_de_pension(antiguedad) * 0.2
  }
  return(salario_referencia(antiguedad, salario, k) * porcentaje_de_salario)
}



```




# Modelos Deterministicos

## Modelo para personas ya pensionadas
Aqui se procede a programar la funcion para estimar valor de las pensiones en curso de pago `PensionMensualDeterministico`
`Edad` (numeric): corresponde a la edad cumplida por el individuos.
`hombre` (boolean): Se indica si es hombre (TRUE) o mujer (FALSE).
`MontoDePension` (numeric): Monto de pension actual.
`tasa_descuento` (numeric): tasa de interes empleada para estimar el valor presente.

```{r}
PensionMensualDeterministico <- function(Edad, hombre, MontoDePension, tasa_descuento) {
  v <- (1) / (1 + tasa_descuento)
  # aguinlado
  MontoAPagar <- MontoDePension
  vectoraguinalado <- c(rep(0, 10), 1, 0)
  vectorMensual <- (seq(1 / 12, (115 - Edad + 1), 1 / 12))
  vectorAnualmensual <- sort(rep(c(0:(115 - Edad)), 12))

  if (hombre) {

    # anualidad inmediata
    anualidad <- pxt(ListaDeTablasHombres[[(Edad + 1)]], x = Edad, t = vectorMensual) *
      (v)^(vectorMensual)
    # monto a pagar con ajuste inflacionario
    MontoAPagar <- MontoAPagar * (1 + 0.04)^(vectorAnualmensual) * 2^(vectoraguinalado)
    suma <- anualidad * MontoAPagar
  } else {
    # anualidad inmediata
    anualidad <- pxt(ListaDeTablasMujeres[[(Edad + 1)]], x = Edad, t = vectorMensual) *
      (v)^(vectorMensual)
    # monto a pagar con ajuste inflacionario
    MontoAPagar <- MontoAPagar * (1 + 0.04)^(vectorAnualmensual) * 2^(vectoraguinalado)
    suma <- anualidad * MontoAPagar
  }
  suma <- sum(suma)
  return(suma)
}
```




### Calculo para las pensiones de los ya pensionados

```{r}
#En este chunk se procede a emplear la funcion para estimar las pensiones
#tanto para hombres como para mujeres

##Calculo para hombres con pension
MontoDePensionMensualParaHombresDeterministicoPensionados <-
  mapply(
    PensionMensualDeterministico,
    pen_hombres$Edad,
    TRUE,
    pen_hombres$MON_PEN,
    0.07
  )

###Se imprime el costo de los hombres
(pensionados_h <- sum(MontoDePensionMensualParaHombresDeterministicoPensionados))

##Calculo de pensión para mujeres con pension
MontoDePensionMensualParaMujeresDeterministicoPensionados <-
  mapply(
    PensionMensualDeterministico,
    pen_mujeres$Edad,
    FALSE,
    pen_mujeres$MON_PEN,
    0.07
  )

###Se imprime el costo de las mujeres
(pensionados_m <- sum(MontoDePensionMensualParaMujeresDeterministicoPensionados))
```

## Comparativa pensiones en curso de pago modelo estocástico y determinístico
Se estima el error relativo del modelo estocástico respecto al deterministico, de las pensiones en curso de pago

```{r, eval=FALSE}
##Total de modelo deterministico
total_determistico <- pensionados_m + pensionados_h

#Total de modelo estocastico
total_estocastico <- pension_pen_m + pension_pen_h

#Errores relativos
##Error relativo mujeres
(error_relativo_m <- abs((pensionados_m - (pension_pen_m))) / (pensionados_m))

##Error relativo hombres
(error_relativo_h <- abs((pensionados_h - (pension_pen_h))) / (pensionados_h))

##Error relativo de todo el calculo
(error_relativo <- abs((pensionados_m + pensionados_h - (pension_pen_m + pension_pen_h))) / (pensionados_m + pensionados_h))

formatC(total_estocastico, format = "f", big.mark = ",", digits = 3, decimal.mark = ".")
```

# Personal activo

## Funcion para decrementos de invalidez y vejez
La siguiente funcion es la empleada para calcular el costo del beneficio obtenido de acuerdo al decremento de vejez o invalidez, es llamada `DecrementoIV` y recibe:

`Edad` (numeric): es la edad cumplida por el individuo.
`hombre` (boolean): indica si el individuo es hombre (`TRUE`) o mujer (`FALSE`).
`antiguedad` (numeric): es el tiempo que lleva el individuo laborando en la empresa.
`ultimo_salario` (numeric): último salario que está recibiendo el individuo.
`tasa_decuento` (numeric): tasa empleada para calcular los montos a valor presente.
`tasa_cre_salario` (numeric): es la tasa real de crecimiento salarial.
`decremento` (numeric): es el número de decremento que se quiere valorar.
`n` (numeric): indica el tiempo en el que puede recibir la pensión. Si se coloca $n=1$ se tiene el individuo puede recibir la pensión
en el periodo en tránsito y el año siguiente.



```{r}

DecrementosIV <- function(Edad, hombre, antiguedad, ultimo_salario, tasa_descuento, tasa_cre_salario, decremento, n = 0) {
  # Se va generar una tabla con los montos definidos para cada edad de pension
  montos_pension <- list()
  v <- (1) / (1 + tasa_descuento)
  edades <- min(Edad):max(Edad)

  # La funcion beneficio aun no ha sido definida
  vectoraguinaldo <- c(rep(0, 10), 1, 0)
  for (i in edades) {
    # Tamaño del vector y posiciones, se va pasar como k
    j <- (0:((115 - i) * (n == 0) + n))
    # Vector donde se van guardando los valores sin tener en cuenta el monto de beneficio, esto ya que se le multiplicará a cada individuo
    # PV_aux <- numeric(length(j))
    # Funcion para estimar cada entrada del PV,  que corresponden
    # a cada uno
    funcion_pv <- function(k) {
      PV_aux <- 0
      if (hombre) {
        # Vector al que se eleva el v
        vectorMensual <- (seq(1 / 12, (115 - i + 1 - k), 1 / 12))
        # Vector para controlar la inflacion
        vectorAnualmensual <- sort(rep(c(0:(115 - i - k)), 12))
        # Vector que contiene los montontos a pagar esto es los montos ajustados por inflacion y multiplicados
        # por si se debería calcular el aguinaldo
        MontoAPagar <- (1 + 0.04)^(vectorAnualmensual) * 2^vectoraguinaldo
        # Vector multiplicando las probabilidad de sobrevivencia es decir tpx*v^t/m
        anualidad <- pxt(ListaDeTablasHombres[[(i + 1)]], x = i + k + 1, t = vectorMensual) * (v)^(vectorMensual)
        # Multiplicando ambos
        suma1 <- sum(anualidad * MontoAPagar)
        PV_aux <- suma1 * v^(k + 1) * pxt1(MDListaDeTablasHombres[[i + 1]], x = i, t = k) * qxt1(MDListaDeTablasHombres[[i + 1]], x = i + k, t = 1, decrement = decremento)
      } else {
        # Vector al que se eleva el v
        vectorMensual <- (seq(1 / 12, (115 - i + 1 - k), 1 / 12))
        # Vector para controlar la inflacion
        vectorAnualmensual <- sort(rep(c(0:(115 - i - k)), 12))
        # Vector que contiene los montontos a pagar esto es los montos ajustados por inflacion y multiplicados
        # por si se debería calcular el aguinaldo
        MontoAPagar <- (1 + 0.04)^(vectorAnualmensual) * 2^vectoraguinaldo
        # Vector multiplicando las probabilidad de sobrevivencia es decir tpx*v^t/m
        anualidad <- pxt(ListaDeTablasMujeres[[(i + 1)]], x = i + k + 1, t = vectorMensual) * (v)^(vectorMensual)
        # Multiplicando ambos
        suma1 <- sum(anualidad * MontoAPagar)
        PV_aux <- suma1 * v^(k + 1) * pxt1(MDListaDeTablasMujeres[[i + 1]], x = i, t = k) * qxt1(MDListaDeTablasMujeres[[i + 1]], x = i + k, t = 1, decrement = decremento)
      }
      return(PV_aux)
    }
    montos_pension[[i - min(Edad) + 1]] <- sapply(FUN = funcion_pv, X = j)
  }
  # Se procede a programar una funcion la cual permite estimar el valor de los individuos
  costo_individuo <- function(edad, antiguedad, ultimo_salario) {
    # Se carga la lista de acuerdo a la edad
    lista <- montos_pension[[edad - min(Edad) + 1]]
    j <- (0:((115 - edad) * (n == 0) + n))
    # Salarios de referencia
    salarios_ref <- unlist(sapply(
      FUN = beneficio, antiguedad = antiguedad,
      decremento = decremento, salario = ultimo_salario, X = j
    ))
    # print(length(lista))
    # print(length(salarios_ref))
    # print(paste(salarios_ref, lista))
    # Se regresa el monto total de los beneficios otorgados
    return(sum(salarios_ref * lista))
  }
  PV <- unlist(mapply(FUN = costo_individuo, edad = Edad, antiguedad = antiguedad, ultimo_salario = ultimo_salario))
  return(PV)
}
```





## Funcion decremento muerte
Se programa la función para estimar la anualidad cierta de 10 años obtenida tras la muerte del individuo `DecrementoM`, recibe los parámetros:

`Edad` (numeric): es la edad cumplida por el individuo.
`hombre` (boolean): indica si el individuo es hombre (`TRUE`) o mujer (`FALSE`).
`antiguedad` (numeric): es el tiempo que lleva el individuo laborando en la empresa.
`ultimo_salario` (numeric): último salario que está recibiendo el individuo.
`tasa_decuento` (numeric): tasa empleada para calcular los montos a valor presente.
`tasa_cre_salario` (numeric): es la tasa real de crecimiento salarial.
`n` (numeric): indica el tiempo en el que puede recibir la pensión. Si se coloca $n=1$ se tiene el individuo puede recibir la pensión
en el periodo en tránsito y el año siguiente.

```{r}

DecrementoM <- function(Edad, hombre, antiguedad, ultimo_salario, tasa_descuento, tasa_cre_salario, n = 0) {
  v <- (1) / (1 + tasa_descuento)
  edades <- min(Edad):max(Edad)
  montos_pension <- list()
  vectoraguinaldo <- c(rep(0, 10), 1, 0)
  vectorMensual <- seq(1 / 12, 10, 1 / 12)
  vectorAnualmensual <- sort(rep(c(0:9), 12))
  for (i in edades) {
    if (n != 0) {
      n <- min(((85 - i) * hombre + (77 - i) * !hombre), n)
    }
    j <- (0:(((85 - i) * hombre + (77 - i) * !hombre) * (n == 0) + n))
    if (hombre) {
      function_pv <- function(k) {
        MontoPagar <- (1 + 0.04)^(vectorAnualmensual) * 2^vectoraguinaldo
        suma1 <- sum((v)^(vectorMensual) * MontoPagar)


        PV_aux <- suma1 * v^(k + 1) * pxt1(MDListaDeTablasHombres[[i + 1]], x = i, t = k) *
          qxt1(MDListaDeTablasHombres[[i + 1]], x = i + k, t = 1, decrement = 4)

        return(PV_aux)
      }
    } else {
      function_pv <- function(k) {
        MontoPagar <- (1 + 0.04)^(vectorAnualmensual) * 2^vectoraguinaldo
        suma1 <- sum((v)^(vectorMensual) * MontoPagar)

        PV_aux <- suma1 * v^(k + 1) * pxt1(MDListaDeTablasMujeres[[i + 1]], x = i, t = k) *
          qxt1(MDListaDeTablasMujeres[[i + 1]], x = i + k, t = 1, decrement = 4)
        return(PV_aux)
      }
    }
    montos_pension[[i - min(Edad) + 1]] <- sapply(FUN = function_pv, X = j)
  }
  costo_individuo <- function(edad, antiguedad, ultimo_salario) {
    # Se carga la lista de acuerdo a la edad
    lista <- montos_pension[[edad - min(Edad) + 1]]
    if (n != 0) {
      n <- min(((85 - edad) * hombre + (77 - edad) * !hombre), n)
    }
    j <- (0:(((85 - edad) * hombre + (77 - edad) * !hombre) * (n == 0) + n))
    # Salarios de referencia
    salarios_ref <- unlist(sapply(
      FUN = beneficio, antiguedad = antiguedad,
      decremento = 4, salario = ultimo_salario, X = j
    ))
    # print(paste(salarios_ref, lista))
    # Se regresa el monto total de los beneficios otorgados
    return(sum(salarios_ref * lista))
  }
  PV <- unlist(mapply(FUN = costo_individuo, edad = Edad, antiguedad = antiguedad, ultimo_salario = ultimo_salario))
  return(PV)
}
```

## Calculo de personas activas IVM

En esta parte se realiza el cálculo del costo de las pensiones.

```{r} 
# Calculo de lo montos para hombres
edades_h <- afil_hombres$Edad
antiguedades_h <- afil_hombres$Antiguedad
salarios_h <- afil_hombres$Salario
tasa_descuento <- 0.07
tasa_crecimiento_r <- 0

# Por invalidez
salida_invalidez_h <- DecrementosIV(edades_h, TRUE, antiguedades_h, salarios_h, tasa_descuento, tasa_crecimiento_r, 1)
# Por jubilacion
salida_jubilacion_h <- DecrementosIV(edades_h, TRUE, antiguedades_h, salarios_h, tasa_descuento, tasa_crecimiento_r, 2)
# Por muerte
salida_muerte_h <- DecrementoM(edades_h, TRUE, antiguedades_h, salarios_h, tasa_descuento, tasa_crecimiento_r)

salida_total_hombres <- salida_invalidez_h + salida_jubilacion_h + salida_muerte_h

afil_hombres$Costo_plan <- salida_total_hombres

suma_invalidez_h <- sum(salida_invalidez_h)
suma_jublicacion_h <- sum(salida_jubilacion_h)
suma_muerte_h <- sum(salida_muerte_h)

#Se imprime y calcula el monto total del costo de las pensiones en curso de pago y la de los empleados activos hombres.
(suma_total_h <- sum(afil_hombres$Costo_plan) + pensionados_h)

### Mujeres
edades_m <- afil_mujeres$Edad
antiguedades_m <- afil_mujeres$Antiguedad
salarios_m <- afil_mujeres$Salario
tasa_descuento <- 0.07
tasa_crecimiento_r <- 0
# Calculo de lo montos para muejeres
# Por invalidez
salida_invalidez_m <- DecrementosIV(edades_m, FALSE, antiguedades_m, salarios_m, 0.07, 0, 1)
# Por jubilacion
salida_jubilacion_m <- DecrementosIV(edades_m, FALSE, antiguedades_m, salarios_m, 0.07, 0, 2)
# Por muerte
salida_muerte_m <- DecrementoM(edades_m, FALSE, antiguedades_m, salarios_m, tasa_descuento, tasa_crecimiento_r)


salida_total_mujeres <- salida_invalidez_m + salida_jubilacion_m + salida_muerte_m

afil_mujeres$Costo_plan <- salida_total_mujeres


suma_invalidez_m <- sum(salida_invalidez_m)
suma_jublicacion_m <- sum(salida_jubilacion_m)
suma_muerte_m <- sum(salida_muerte_m)


#Se imprime y calcula el monto total del costo de las pensiones en curso de pago y la de los empleados activos.
(suma_total_m <- sum(afil_mujeres$Costo_plan) + pensionados_m)
```




# Liquidación 

En esta sección se programan las funciones necesarias para el cálculo de los costos de liquidación. 

## Función para liquidación

Se programa la función `liquidacion` que corresponde a la empleada para el cálculo de la liquidación dados los aportes que se debieron realizar, recibe:
`edad` (numeric): la edad cumplida por el individuo.
`salario_actual` (numeric): es el salario con el que cuenta actualmente el individuo.
`antiguedad` (numeric): tiempo cumplido que lleva laborando en la empresa.
`i` (numeric): tasa de decuento empleada para calcular los montos en valor presente.
`inflacion` (numeric): inflación a largo plazo.
`aumento_real` (numeric): aumento real que tienen los salarios.
`porcentaje_aporte` (numeric): porcentaje de aportes que debieron realiza anteriormentes.
`sexo` (boolean): indica si es hombre (`TRUE`) o mujer (`FALSE`).


```{r}
liquidacion <- function(edad, salario_actual, antiguedad, i, inflacion, aumento_real, porcentaje_aporte, sexo) {
  if (antiguedad + 2 <= 22) {
    v <- 1 / (1 + i)
    # Para estimar el aumento que se le hizo al salario inicial hasta el momento
    aumento <- (1 + inflacion) * (1 + aumento_real)

    # Salario con el que se inició
    salario_inicial <- salario_actual * (aumento)^(-antiguedad) * porcentaje_aporte

    # Salarios que han sido pagados para el momento de la liquidación
    salarios <- salario_inicial * aumento^(0:(antiguedad + 2))
    salarios <- sort(rep(salarios, 12))
    # Se crea un vector con 12 salarios de cada año
    descontado <- v^seq(1 / 12, antiguedad + 3, 1 / 12) * (1 + i)^(antiguedad + 1)

    # Se multiplica el descontado con los salarios pagados
    monto <- sum(salarios * descontado)
    if (!sexo) {
      p <- pxt1(MDListaDeTablasMujeres[[edad + 1]], x = edad, t = 2)
    } else if (sexo) {
      p <- pxt1(MDListaDeTablasHombres[[edad + 1]], x = edad, t = 2)
    }
    return(monto * p)
  } else {
    return(0)
  }
}


```







## Calculo de costos de liquidación

Aquí se estima los costos de liquidación tomando en cuenta que se pueden pensionar dentro de los siguiente dos años y el costo de liquidar o trasladar los aportes
en caso de que se llegue a pensionar.
```{r}
# Costo liquidacion de hombres que no se pensionan
liquidacion_h <- mapply(
  FUN = liquidacion,
  edad = edades_h, salario_actual = salarios_h, antiguedad = antiguedades_h,
  i = interes, inflacion = inflacion, aumento_real = aumento_real, porcentaje = porcentaje_aporte,
  sexo = TRUE
)
#Monto invalidez hombres
salida_invalidez_h_18 <- DecrementosIV(edades_h, TRUE, antiguedades_h, salarios_h, tasa_descuento, tasa_crecimiento_r, 1, 1)

#Monto por jubilacion hombres
salida_jubilacion_h_18 <- DecrementosIV(edades_h, TRUE, antiguedades_h, salarios_h, tasa_descuento, tasa_crecimiento_r, 2, 1)
#Monto por muerte hombres
salida_muerte_h_18 <- DecrementoM(edades_h, TRUE, antiguedades_h, salarios_h, tasa_descuento, tasa_crecimiento_r, 1)

#Monto total 
salida_total_hombres_18 <- salida_invalidez_h_18 + salida_jubilacion_h_18 + salida_muerte_h_18 + liquidacion_h

#Se agregan a la tabla de los hombres
afil_hombres$Costo_plan_18 <- salida_total_hombres_18

#Se imprime la suma de los montos
(suma_invalidez_h_18 <- sum(salida_invalidez_h_18))
(suma_jublicacion_h_18 <- sum(salida_jubilacion_h_18))
(suma_muerte_h_18 <- sum(salida_muerte_h_18))
(suma_liquidacion_h <- sum(liquidacion_h))
(suma_total_h_18 <- sum(afil_hombres$Costo_plan_18) + pensionados_h)


# Costo liquidacion de mujeres que no se pensionan
liquidacion_m <- mapply(
  FUN = liquidacion,
  edad = edades_m, salario_actual = salarios_m, antiguedad = antiguedades_m,
  i = interes, inflacion = inflacion, aumento_real = aumento_real, porcentaje = porcentaje_aporte,
  sexo = FALSE
)

#Monto por invalidez mujeres
salida_invalidez_m_18 <- DecrementosIV(edades_m, TRUE, antiguedades_m, salarios_m, tasa_descuento, tasa_crecimiento_r, 1, 1)

#Monto por jubilacionn mujeres
salida_jubilacion_m_18 <- DecrementosIV(edades_m, TRUE, antiguedades_m, salarios_m, tasa_descuento, tasa_crecimiento_r, 2, 1)

#Monto por muerte mujeres
salida_muerte_m_18 <- DecrementoM(edades_m, TRUE, antiguedades_m, salarios_m, tasa_descuento, tasa_crecimiento_r, 1)

#Monto total mujeres
salida_total_mujeres_18 <- salida_invalidez_m_18 + salida_jubilacion_m_18 + salida_muerte_m_18 + liquidacion_m

#Se agrega a la tabla de mujeres
afil_mujeres$Costo_plan_18 <- salida_total_mujeres_18

#Se imprimen los montos
(suma_invalidez_m_18 <- sum(salida_invalidez_m_18))
(suma_jublicacion_m_18 <- sum(salida_jubilacion_m_18)
(suma_muerte_m_18 <- sum(salida_muerte_m_18))
(suma_liquidacion_m <- sum(liquidacion_m))
(suma_total_m_18 <- sum(afil_mujeres$Costo_plan_18) + pensionados_m)
```


Se procede a construir una tabla en la cual se muestran los Resultados

```{r}
# Empleados activos
hombres_activos <- c(suma_invalidez_h, suma_jublicacion_h, suma_muerte_h, suma_invalidez_h + suma_jublicacion_h + suma_muerte_h, pensionados_h, suma_total_h)
mujeres_activos <- c(suma_invalidez_m, suma_jublicacion_m, suma_muerte_m, suma_invalidez_m + suma_jublicacion_m + suma_muerte_m, pensionados_m, suma_total_m)


# Liquidacion
hombres_liquidacion <- c(suma_invalidez_h_18, suma_jublicacion_h_18, suma_muerte_h_18, suma_liquidacion_h, suma_invalidez_h_18 + suma_jublicacion_h_18 + suma_muerte_h_18 + suma_liquidacion_h, pensionados_h, suma_total_h_18)
mujeres_liquidacion <- c(suma_invalidez_m_18, suma_jublicacion_m_18, suma_muerte_m_18, suma_liquidacion_m, suma_invalidez_m_18 + suma_jublicacion_m_18 + suma_muerte_m_18 + suma_liquidacion_m, pensionados_m, suma_total_m_18)

# Montos
etiquetas <- c("Invalidez", "Jubilación", "Muerte", "Subtotal", "En curso de pago", "Total")

costos_liquidacion <- c(suma_total_h_18, suma_total_m_18, suma_total_h_18 + suma_total_m_18)

tabla_resultados <- data.frame("Etiquetas" = etiquetas, "Hombres" = hombres_activos, "Mujeres" = mujeres_activos)
(tabla_resultados %<>% mutate("Total" = Hombres + Mujeres))
print(xtable(tabla_resultados, type = "latex", tabular.environment = "longtable"),
  format.args = list(big.mark = ",", decimal.mark = "."),
  file = "tabla_resultados.tex"
)


#Tabla para la liquidacion
etiquetas_liquidacion <- c("Invalidez", "Jubilación", "Muerte", "Liquidación", "Subtotal", "En curso de pago", "Total")
tabla_liquidacion <- data.frame("Etiquetas" = etiquetas_liquidacion, "Hombres" = hombres_liquidacion, "Mujeres" = mujeres_liquidacion)
(tabla_liquidacion %<>% mutate("Total" = Hombres + Mujeres))
print(xtable(tabla_liquidacion, type = "latex", tabular.environment = "longtable"),
  format.args = list(big.mark = ",", decimal.mark = "."),
  file = "tabla_liquidacion.tex"
)

# Resultados comparativos entre planes de beneficios
proporciones <- c(suma_total_h_18 / suma_total_h, suma_total_m_18 / suma_total_m, (suma_total_m_18 + suma_total_h_18) / (suma_total_h + suma_total_m))
(tabla_proporciones <- data.frame("Hombres" = proporciones[1], "Mujeres" = proporciones[2], "Total" = proporciones[3]))
print(xtable(tabla_proporciones, type = "latex", tabular.environment = "longtable"),
  format.args = list(big.mark = ",", decimal.mark = "."),
  file = "tabla_proporciones.tex"
)
```




## Compartiva de costos del plan de beneficios y liquidación.

En esta sección se generan los gráficos para realizar la comparativa entre el costo del plan de beneficios y la liquidación. Para ello se presentan tres escenarios uno en 
el que se agrupa por antigüedad, por edad y por salario. Para ello se calcula el cociente del costo de liquidación por grupo dividio entre el costo del plan de beneficios
por grupo.

### Por antigüedad

```{r}
suma_costos_ant_h <- afil_hombres %>%
  group_by(Antiguedad) %>%
  summarise(
    Montos_plan = sum(Costo_plan),
    Montos_liquidacion = sum(Costo_plan_18)
  )
suma_costos_ant_m <- afil_mujeres %>%
  group_by(Antiguedad) %>%
  summarise(
    Montos_plan = sum(Costo_plan),
    Montos_liquidacion = sum(Costo_plan_18)
  )



suma_costos_ant <- merge(suma_costos_ant_h, suma_costos_ant_m,
  by = "Antiguedad", all.x = TRUE
)
suma_costos_ant[is.na(suma_costos_ant)] <- 0
suma_costos_ant %<>% mutate(
  Montos_plan = Montos_plan.x + Montos_plan.y,
  Montos_liquidacion = Montos_liquidacion.x + Montos_liquidacion.y,
  .keep = "unused"
) %>% mutate(Proporcion = Montos_liquidacion / Montos_plan*100)


print(xtable(suma_costos_ant, type = "latex", tabular.environment = "longtable"),
  format.args = list(big.mark = ",", decimal.mark = "."),
  file = "suma_costos_ant.tex"
)

# suma_costos_edad %<>% mutate(Edad = factor(Edad, levels = suma_costos_edad$Edad)) %>% arrange(Edad)
grafico_barras_ant <- suma_costos_ant %>% ggplot() +
  geom_bar(aes(x = Antiguedad, y = Proporcion),
    stat = "identity",
    position = position_dodge(),
    fill = "red",
    width = 0.8
  ) +
  scale_x_continuous(name = "Antigüedad", breaks = seq(min(suma_costos_ant$Antiguedad), max(suma_costos_ant$Antiguedad), 5)) +
  scale_y_continuous(name = "Porcentaje", breaks = seq(0, 100, 10)) +
  theme_minimal()+theme(axis.text.x = element_text(size=15),
          axis.text.y = element_text(size=15),
          axis.title.x = element_text(size=20),
          axis.title.y = element_text(size=20)
  )
grafico_barras_ant
ggsave("grafico_barras_ant.eps")
```

### Por grupo etario

```{r}
suma_costos_edad_h <- afil_hombres %>%
  group_by(Edad) %>%
  summarise(
    Montos_plan = sum(Costo_plan),
    Montos_liquidacion = sum(Costo_plan_18)
  )
suma_costos_edad_m <- afil_mujeres %>%
  group_by(Edad) %>%
  summarise(
    Montos_plan = sum(Costo_plan),
    Montos_liquidacion = sum(Costo_plan_18)
  )



suma_costos_edad <- merge(suma_costos_edad_h, suma_costos_edad_m,
  by = "Edad", all.x = TRUE
)
suma_costos_edad[is.na(suma_costos_edad)] <- 0
suma_costos_edad %<>% mutate(
  Montos_plan = Montos_plan.x + Montos_plan.y,
  Montos_liquidacion = Montos_liquidacion.x + Montos_liquidacion.y,
  .keep = "unused"
) %>% mutate(Proporcion = Montos_liquidacion / Montos_plan * 100)




grafico_barras_edad <- suma_costos_edad %>% ggplot() +
  geom_bar(aes(x = Edad, y = Proporcion),
    stat = "identity",
    position = position_dodge(),
    fill = "red",
    width = 0.8
  ) +
  scale_x_continuous(name = "Edad", breaks = seq(min(suma_costos_edad$Edad), max(suma_costos_edad$Edad), 5)) +
  scale_y_continuous(name = "Porcentaje", breaks = seq(0, 100, 10)) +
  theme_minimal()+theme(axis.text.x = element_text(size=15),
          axis.text.y = element_text(size=15),
          axis.title.x = element_text(size=20),
          axis.title.y = element_text(size=20)
  )




grafico_barras_edad
ggsave("grafico_barras_edad.eps")
```
### Por intervalo salarial

```{r}
tabla_conjunta<- rbind(afil_hombres,afil_mujeres)
k<-quantile(tabla_conjunta$Salario/1000,seq(0,1,length.out=15))#nclass.Sturges(tabla_conjunta$Salario/1000)

tabla_conjunta$Intervalos<-cut(tabla_conjunta$Salario/1000,breaks=k,include.lowest=TRUE,dig.lab=5)

#Grafico de barras salario
suma_costos_salario <- tabla_conjunta %>%
  group_by(Intervalos) %>%
  summarise(
    Montos_plan = sum(Costo_plan),
    Montos_liquidacion = sum(Costo_plan_18)
  )






suma_costos_salario %<>% mutate(Proporcion = Montos_liquidacion / Montos_plan * 100)




grafico_barras_salario <- suma_costos_salario %>% ggplot() +
  geom_bar(aes(x = Intervalos, y = Proporcion),
    stat = "identity",
    position = position_dodge(),
    fill = "red",
    width = 0.8
  ) +
  theme_minimal(

  )+theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1,size=15),
          axis.text.y = element_text(size=15),
          axis.title.x = element_text(size=20),
          axis.title.y = element_text(size=20)
  )+xlab('Salario en miles de colones')+ylab('Porcentaje')




grafico_barras_salario
ggsave("grafico_barras_salario.eps")

```



# Ajustes para poder reducir los costos
En esta sección se realizaron distintos cambios al código para poder ajustar los costos, buscando un 0.015 como prima media nivelada. 
Se muestra al final una tabla con los resultados tras trabajar con el código.
Se añade a `beneficio` la variable:

`n` (numeric): numero de salarios que se toman de forma anual para el promedio.

```{r}
#Porcentaje de salario de tal forma que de acuerdo a la antiguedad se hace antiguedad/100 desde edad 5 hasta edad 35.
#Y se deja en 0.4 más de 35 años
porcentaje_de_pension <- function(antiguedad) {
    if(antiguedad>=5 && antiguedad < 35){
      return(antiguedad/100)
    }else if(antiguedad >= 35){
      return(0.4)
    }else if(antiguedad < 5){
      return(0)
    }
}

#Se agrega un paramtro para determianr cual es la cantidad de salarios que se toman para el promedio
#y se coloca un tope de 1,500,000 como monto que se puede recibir de salida
beneficio <- function(antiguedad, decremento, salario, k, n = 5) { 
  antiguedad <- antiguedad + k 
  # invalidez 
  if (decremento == 1) { 
    porcentaje_de_salario <- porcentaje_de_pension(antiguedad) * 0.6 
    # vejez 
  } else if (decremento == 2) { 
    porcentaje_de_salario <- porcentaje_de_pension(antiguedad) 
    # muerte 
  } else if (decremento == 4) { 
    porcentaje_de_salario <- porcentaje_de_pension(antiguedad) * 0.2 
  } 
  
  beneficio<-salario_referencia(antiguedad - k, salario, k, n) / 12 * porcentaje_de_salario
  beneficio<-min(beneficio, 1500000)
  return(beneficio) 
} 
```

## Distintos escenarios de reservas
Se programó una función en la cuál se estiman cuales hubieran sido los valores de reservas
si se hubieran cobrado distintos montos desde que se ingresó a la compañía.
`reservas` es la función creada para estimar estas reservas que se hubieran obtenido, recibe:
`edad` (numeric): edad cumplida por el individuo al momento de valoración.
`salario_actual` (numeric): salario que recibe al momento de valoración.
`antiguedad` (numeric): número de años cumplidos desde que se ingresó a la empresa.
`i` (numeric): tasa empleada para estimar el valor presente.
`inflacion` (numeric): inflación de largo plazo.
`aumento_real` (numeric): aumento real de los salarios.
`porcentaje_aporte` (numeric): porcentaje de aporte que se supone realizó desde que se ingresó,
sobre los salarios.
`sexo` (boolean): indica si el individuo es hombre (`TRUE`) o mujer (`FALSE`).

```{r}
#Funcion para calculo de reservas 
reservas <- function(edad, salario_actual, antiguedad, i, inflacion, aumento_real, porcentaje_aporte, sexo) { 
 
    v <- 1 / (1 + i) 
    # Para estimar el aumento que se le hizo al salario inicial hasta el momento 
    aumento <- (1 + inflacion) * (1 + aumento_real) 
 
    # Salario con el que se inició 
    salario_inicial <- salario_actual * (aumento)^(-antiguedad) * porcentaje_aporte 
 
    # Salarios que han sido pagados para el momento de la liquidación 
    salarios <- salario_inicial * aumento^(0:(antiguedad )) 
    salarios <- sort(rep(salarios, 12)) 
    # Se crea un vector con 12 salarios de cada año 
    descontado <- v^seq(1 / 12, antiguedad + 1, 1 / 12) * (1 + i)^(antiguedad + 1) 
 
    # Se multiplica el descontado con los salarios pagados 
    monto <- sum(salarios * descontado) 
    if (!sexo) { 
      p <- pxt1(MDListaDeTablasMujeres[[edad + 1]], x = edad, t = 2) 
    } else if (sexo) { 
      p <- pxt1(MDListaDeTablasHombres[[edad + 1]], x = edad, t = 2) 
    } 
    return(monto * p) 
   
} 
 
#Calculo de reservas hombres 1.5%
reservas_hombres<-mapply( 
  FUN = reservas, 
  edad = edades_h, salario_actual = salarios_h, antiguedad = antiguedades_h, 
  i = interes, inflacion = inflacion, aumento_real = aumento_real, porcentaje = porcentaje_aporte, 
  sexo = TRUE 
) 
#Calculo de reservas mujeres 1.5%
reservas_mujeres<-mapply( 
  FUN = reservas, 
  edad = edades_m, salario_actual = salarios_m, antiguedad = antiguedades_m, 
  i = interes, inflacion = inflacion, aumento_real = aumento_real, porcentaje = porcentaje_aporte, 
  sexo = FALSE 
) 
#Total con aporte del 1.5%
(reserva_total<- sum(reservas_hombres)+sum(reservas_mujeres))

#Resevar con 5% de aportes
aporte<- 0.05
#Calculo de reservas hombres al 5%
reservas_hombres_5<-mapply( 
  FUN = reservas, 
  edad = edades_h, salario_actual = salarios_h, antiguedad = antiguedades_h, 
  i = interes, inflacion = inflacion, aumento_real = aumento_real, porcentaje = aporte, 
  sexo = TRUE 
) 
#Calculo de reservas mujeres al 5%
reservas_mujeres_5<-mapply( 
  FUN = reservas, 
  edad = edades_m, salario_actual = salarios_m, antiguedad = antiguedades_m, 
  i = interes, inflacion = inflacion, aumento_real = aumento_real, porcentaje = aporte, 
  sexo = FALSE 
) 
#Reseva al 5%
(reserva_total_5<- sum(reservas_hombres_5)+sum(reservas_mujeres_5))
```



### Función masa salaria

Se programa una función para estimar la masa salarial `cotizacionfutura`, recibe:
`Edad` (numeric): edad cumplida a la fecha de valoración.
`hombre` (boolean): indica si el individuo es hombre (`TRUE`) o mujer (`FALSE`).
`ultimo_salario` (numeric): salario recibido en el año de valoración.
`t` (numeric): omega de la tabla de mortalidad.
`porcentaje_aporte`: indica el porcentaje que se quiere de los salarios futuros.

```{r}
cotizacionfutura <- function(Edad, hombre, ultimo_salario, t=117,porcentaje_aporte=1) {
    v <- (1) / (1 + 0.07 )
    if (hombre) {
      t<-min(85-Edad,t)
      salariosfuturos<-ultimo_salario * ((1 + 0.04)*(1+0.025))^(1:(t))*12*
        pxt1(MDListaDeTablasHombres[[Edad+1]], x = Edad, t = (1:t))* v^(0:(t-1))
        return(salariosfuturos*porcentaje_aporte)
      } else {
        t<-min(77-Edad,t)
      salariosfuturos<-ultimo_salario * ((1 + 0.04)*(1+0.025))^(1:(t))*12*
        pxt1(MDListaDeTablasMujeres[[Edad+1]], x = Edad, t = (1:t))* v^(0:(t-1))
        return(salariosfuturos*porcentaje_aporte)
      }  
    }
#Se calcula el monto para las mujers y para los hombres
SalariosM<-mapply( cotizacionfutura,  afil_mujeres$Edad, FALSE, afil_mujeres$Salario)
SalariosH<-mapply( cotizacionfutura,  afil_hombres$Edad, TRUE, afil_hombres$Salario)
```

Se muestran algunos de los resultados obtenidos


```{r}
CostoTotal<-sum(afil_mujeres$Costo_plan)+sum(afil_hombres$Costo_plan)
#Valor de la masa salarial
(ValorPresenteDeMasaSalarial<-(sum(unlist(SalariosM))+sum(unlist(SalariosH))))

#Reserva necesaria 
(reservaNecesaria<- CostoTotal-0.015*(sum(unlist(SalariosM))+sum(unlist(SalariosH))))

#Caso uno solo le dan un 0.008 del beneficio
(pi_1<-(CostoTotal*0.08)/ValorPresenteDeMasaSalarial)
#Caso uno solo le dan una reserva al 5% de contribuciones anteriores
(pi_2<-(CostoTotal*0.525-reserva_total_5)/ValorPresenteDeMasaSalarial)

#Caso original
(CostoTotal/ValorPresenteDeMasaSalarial)
```


