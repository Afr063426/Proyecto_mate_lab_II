---
title: "Proyecto"
author: "Daniel Sabater"
date: '2022-06-05'
output: html_document
---

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
# Programacion hecha por Joshua Cervantes, Moisés Monge y Daniel Sabater
# Se cargan los paquetes
knitr::opts_chunk$set(echo = FALSE)
options(scipen = 999)
library(lifecontingencies)
library(tidyverse)
library(lubridate)
library(readxl)
library(kableExtra)
library(xtable)
library(stringr)
library(magrittr) # uso de %<>% con funciones de dplyr


# Para paralelizar
library(future.apply)
plan(multicore)

# Se cargan las bases de datos

Afiliados_31_12_2021 <- read_excel("Planilla_Compañia_31_12_2021.xlsx")
Pensionados_31_12_2021 <- read_excel("Compañia_Pensionados_31_12_2021.xlsx", range = "A1:F5006")


# Tablas de decrementos

TablasDecrementosHombres <- read_excel("Tablas de decrementos.xlsx",
  sheet = "Hombres"
)
TablasDecrementosMujeres <- read_excel("Tablas de decrementos.xlsx",
  sheet = "Mujeres"
)


# Tablas de mortalidad dinámicas


TablaDinamica_lxsHombres <- as.data.frame(read_excel("TablaDinamica-lxs.xlsx",
  sheet = "Hombres"
))
TablaDinamica_lxsMujeres <- as.data.frame(read_excel("TablaDinamica-lxs.xlsx",
  sheet = "Mujeres"
))


# Se genera lista con las tablas actuariales de los hombres

ListaDeTablasHombres <- list()
for (j in 1:(length(TablaDinamica_lxsHombres) - 1)) {
  ListaDeTablasHombres[[j]] <- with(
    TablaDinamica_lxsHombres,
    new(
      "actuarialtable",
      interest = 0.06,
      x = TablaDinamica_lxsHombres[, 1],
      lx = TablaDinamica_lxsHombres[, j + 1],
      name = paste("E", (j - 1), sep = "")
    )
  )
}

names(ListaDeTablasHombres) <- paste("E", seq(0, 115), sep = "")

# Se genera lista con las tablas actuariales de las mujeres

ListaDeTablasMujeres <- list()
for (j in 1:(length(TablaDinamica_lxsMujeres) - 1)) {
  ListaDeTablasMujeres[[j]] <- with(
    TablaDinamica_lxsMujeres,
    new(
      "actuarialtable",
      interest = 0.06,
      x = TablaDinamica_lxsMujeres[, 1],
      lx = TablaDinamica_lxsMujeres[, j + 1],
      name = paste("E", (j - 1), sep = "")
    )
  )
}

names(ListaDeTablasMujeres) <- paste("E", seq(0, 115), sep = "")

# Se establece la fecha de la valuación

dia_de_evaluacion <- as.Date("31/12/2021", format = "%d/%m/%Y")

# Afiliados

# Cálculo de edades afiliados

edad <- floor(time_length(difftime(
  dia_de_evaluacion,
  as.Date(as.POSIXct(Afiliados_31_12_2021$Fecha_nacimiento), "UTC")
), "years"))

# Depuración de la columna 'Fecha_ingreso'

Afiliados_31_12_2021 %<>% mutate(Fecha_ingreso = paste(substr(Fecha_ingreso, 1, 4),
  "/", substr(Fecha_ingreso, 5, 6), "/", substr(Fecha_ingreso, 7, 8),
  sep = ""
))

# Depuración de la columna 'Fecha_nacimiento'

Afiliados_31_12_2021 %<>% mutate(Fecha_nacimiento = format(Fecha_nacimiento, "%Y/%m/%d"))

# Cálculo de antigüedad

antiguedad <- floor(time_length(difftime(
  dia_de_evaluacion,
  as.Date(
    Afiliados_31_12_2021$Fecha_ingreso,
    "%Y/%m/%d"
  )
), "years"))

# Inclusión de las variables de edad y antigüedad en la base de datos

Afiliados_31_12_2021 %<>% mutate("Edad" = edad, "Antiguedad" = antiguedad)

# Se calcula edad de los pensionados

Pensionados_31_12_2021 %<>% mutate(FEC_NAC = paste(substr(FEC_NAC, 1, 4),
  "/", substr(FEC_NAC, 5, 6), "/", substr(FEC_NAC, 7, 8),
  sep = ""
))

Pensionados_31_12_2021 %<>% mutate(FEC_RIG_PEN = paste(substr(FEC_RIG_PEN, 1, 4),
  "/", substr(FEC_RIG_PEN, 5, 6), "/", substr(FEC_RIG_PEN, 7, 8),
  sep = ""
))

edad <- floor(time_length(
  difftime(
    dia_de_evaluacion,
    as.Date(
      Pensionados_31_12_2021$FEC_NAC,
      "%Y/%m/%d"
    )
  ),
  "years"
))

tiempo_pension <- floor(time_length(
  difftime(
    dia_de_evaluacion,
    as.Date(
      Pensionados_31_12_2021$FEC_RIG_PEN,
      "%Y/%m/%d"
    )
  ),
  "years"
))

Pensionados_31_12_2021 %<>% mutate("Edad" = edad, "T_Pension" = tiempo_pension)

# se crean bases de datos según genero

afil_hombres <- Afiliados_31_12_2021 %>% filter(Sexo == "M")
pen_hombres <- Pensionados_31_12_2021 %>% filter(SEX == "M")
afil_mujeres <- Afiliados_31_12_2021 %>% filter(Sexo == "F")
pen_mujeres <- Pensionados_31_12_2021 %>% filter(SEX == "F")

# Inflacion
inflacion <- 0.04

# Aumentos real
aumento_real <- 0.0150

# Porcentaje de aporte
porcentaje_aporte <- 0.015

# Interes
interes <- 0.07
```

## Tablas de multiples decrementos


```{r message=FALSE, warning=FALSE}

ProMuerte <- function(q1, q2, q3, q4) {
  a <- q1 * ((-3 * q2 * q3 * q4) / 12 + 4 * (q2 * q3 + q3 * q4 + q4 * q2) / 12 - 6 * (q2 + q3 + q4) / 12 + 1)
  b <- q2 * ((-3 * q1 * q3 * q4) / 12 + 4 * (q1 * q3 + q3 * q4 + q4 * q1) / 12 - 6 * (q1 + q3 + q4) / 12 + 1)
  c <- q3 * ((-3 * q2 * q1 * q4) / 12 + 4 * (q2 * q1 + q1 * q4 + q4 * q2) / 12 - 6 * (q2 + q1 + q4) / 12 + 1)
  d <- q4 * ((-3 * q2 * q3 * q1) / 12 + 4 * (q2 * q3 + q3 * q1 + q1 * q2) / 12 - 6 * (q2 + q3 + q1) / 12 + 1)
  qx <- (a + b + c + d)

  return(data.frame("qx1" = a, "qx2" = b, "qx3" = c, "qx4" = d, "qxC" = qx))
}

# Se genera lista con las tablas de multiples decrementos de los hombres

MDListaDeTablasHombres <- list()
for (m in 1:116) {
  qxs <- ProMuerte(TablasDecrementosHombres$Invalidez, TablasDecrementosHombres$Jubilacion, TablasDecrementosHombres$Retiro, qxt(ListaDeTablasHombres[[m]], 0:115, 1))

  Tabladevida <- as.data.frame(qxs)

  Tabladevida$lx <- (1000000:(1000000 - 115))

  for (i in 1:115) {
    Tabladevida$lx[i + 1] <- Tabladevida$lx[i] - Tabladevida$lx[i] * Tabladevida$qxC[i]
  }

  Tabladevida$d1 <- Tabladevida$lx * Tabladevida$qx1
  Tabladevida$d2 <- Tabladevida$lx * Tabladevida$qx2
  Tabladevida$d3 <- Tabladevida$lx * Tabladevida$qx3
  Tabladevida$d4 <- Tabladevida$lx * Tabladevida$qx4

  Tabladevida$d4[1] + Tabladevida$lx[2]

  MDListaDeTablasHombres[[m]] <-
    new(
      "mdt",
      table = Tabladevida[, 7:10],
      name = paste("E", (m - 1), sep = "")
    )
}

names(MDListaDeTablasHombres) <- paste("E", seq(0, 115), sep = "")



# Se genera lista con las tablas de multiples decrementos de las mujeres

MDListaDeTablasMujeres <- list()
for (m in 1:116) {
  qxs <- ProMuerte(TablasDecrementosMujeres$Invalidez, TablasDecrementosMujeres$Jubilacion, TablasDecrementosMujeres$Retiro, qxt(ListaDeTablasMujeres[[m]], 0, c(1:116)))

  Tabladevida <- as.data.frame(qxs)

  Tabladevida$lx <- (1000000:(1000000 - 115))

  for (i in 1:115) {
    Tabladevida$lx[i + 1] <- Tabladevida$lx[i] - Tabladevida$lx[i] * Tabladevida$qxC[i]
  }

  Tabladevida$d1 <- Tabladevida$lx * Tabladevida$qx1
  Tabladevida$d2 <- Tabladevida$lx * Tabladevida$qx2
  Tabladevida$d3 <- Tabladevida$lx * Tabladevida$qx3
  Tabladevida$d4 <- Tabladevida$lx * Tabladevida$qx4

  Tabladevida$d4[1] + Tabladevida$lx[2]

  MDListaDeTablasMujeres[[m]] <-
    new(
      "mdt",
      table = Tabladevida[, 7:10],
      name = paste("E", (m - 1), sep = "")
    )
}

names(MDListaDeTablasMujeres) <- paste("E", seq(0, 115), sep = "")

rm(qxs)
```

Las tablas de decrementos constituyen
 Decremento 1: invalidez
 Decremento 2: jubilación
 Decremento 3: retiro
 Decremento 4: muerte

 
 
# Funciones que nos sirven a todos


```{r}
# porcentaje de pensión
porcentaje_de_pension <- function(antiguedad) {
  
  porcebtajeVejez <- c((antiguedad >= 5 & antiguedad < 10) * 0.10 +
                         (antiguedad >= 10 & antiguedad < 15) * 0.15 +
                         (antiguedad >= 15 & antiguedad < 20) * 0.20 +
                         (antiguedad >= 20 & antiguedad < 25) * 0.25 +
                         (antiguedad >= 25 & antiguedad < 30) * 0.30 +
                         (antiguedad >= 30 & antiguedad < 35) * 0.35 +
                         (antiguedad >= 35) * 0.4)
  
return(porcebtajeVejez)
}


beneficio <- function(antiguedad, decremento, salario, k) {
  antiguedad<-antiguedad+k
  #invalidez
  if (decremento==1 ) {
    porcentaje_de_salario<-porcentaje_de_pension(antiguedad)*0.6
  #vejez
  }else if(decremento==2){
    porcentaje_de_salario<-porcentaje_de_pension(antiguedad)
  #muerte
  }else if(decremento==4){
    porcentaje_de_salario<-porcentaje_de_pension(antiguedad)*0.2
  }
  return(salario_referencia(antiguedad-k, salario, k)/12 *porcentaje_de_salario) 


RebajoFondosInsuficientes <- function(MontodePension) {
  MontoRebajado <- c(
    MontodePension * 0.10 +
      (MontodePension >= 2293400) * 0.35 * MontodePension +
      (MontodePension >= 2866750) * 0.45 * MontodePension +
      (MontodePension >= 3583437.50) * 0.55 * MontodePension +
      (MontodePension >= 4479296.88) * 0.65 * MontodePension
  )
  if (MontoRebajado > MontodePension * 0.55) {
    return(MontodePension * 0.55)
  }
  return(MontoRebajado)
}
```

## Escala salarial

```{r}
# Aqui voy a programar la tabla de escala salarial
# se debe hacer por sexo y por edad
# de momentos se calculará el promedio por edad
# Se estima una función lineal entre los dos puntos que faltan
# Pensando si hacerlo por splines
media_mujeres <- aggregate(afil_mujeres$Salario, list(afil_mujeres$Edad), FUN = mean)
media_hombres <- aggregate(afil_hombres$Salario, list(afil_hombres$Edad), FUN = mean)
j <- 2
while (j <= nrow(media_mujeres)) {
  diferencia <- media_mujeres$Group.1[j] - media_mujeres$Group.1[j - 1]
  if (diferencia != 1) {
    m <- (media_mujeres$x[j] - media_mujeres$x[j - 1]) /
      (media_mujeres$Group.1[j] - media_mujeres$Group.1[j - 1])
    b <- media_mujeres$x[j] - m * media_mujeres$Group.1[j]
    edad_faltantes <- media_mujeres$Group.1[j - 1] + (1:(diferencia - 1))
    montos <- m * edad_faltantes + b
    faltantes <- data.frame(Group.1 = edad_faltantes, x = montos)
    media_mujeres <- rbind(media_mujeres[1:j - 1, ], faltantes, media_mujeres[j:nrow(media_mujeres), ])
  }
  j <- j + 1
}
j <- 2
while (j <= nrow(media_hombres)) {
  diferencia <- media_hombres$Group.1[j] - media_hombres$Group.1[j - 1]
  if (diferencia != 1) {
    m <- (media_hombres$x[j] - media_hombres$x[j - 1]) /
      (media_hombres$Group.1[j] - media_hombres$Group.1[j - 1])
    b <- media_hombres$x[j] - m * media_hombres$Group.1[j]
    edad_faltantes <- media_hombres$Group.1[j - 1] + (1:(diferencia - 1))
    montos <- m * edad_faltantes + b
    faltantes <- data.frame(Group.1 = edad_faltantes, x = montos)
    media_hombres <- rbind(media_hombres[1:j - 1, ], faltantes, media_hombres[j:nrow(media_hombres), ])
  }
  j <- j + 1
}
# Mujeres
edad_m <- max(media_mujeres$Group.1)
sal_m <- rep(max(media_mujeres$x), 85 - edad_m)
sal_m <- data.frame(Group.1 = c((edad_m + 1):85, 18), x = c(sal_m, media_mujeres$x[1]))
media_mujeres %<>% rbind(sal_m)

# Hombres
edad_h <- max(media_hombres$Group.1)
sal_h <- rep(max(media_hombres$x), 85 - edad_h)
sal_h <- data.frame(Group.1 = (edad_h + 1):85, x = sal_h)
media_hombres %<>% rbind(sal_h)

# Ordenamiento
media_mujeres <- media_mujeres[order(media_mujeres$Group.1), ]
media_hombres <- media_hombres[order(media_hombres$Group.1), ]

# Unificacion
escala <- data.frame(Edad = 18:85, Hombres = media_hombres$x, Mujeres = media_mujeres$x)
min_m <- escala$Mujeres[1]
min_h <- escala$Hombres[1]
escala %<>% mutate(Hombres = Hombres / min_h, Mujeres = Mujeres / min_m)
write.csv(escala, "./Escala_edad.csv", row.names = FALSE)
```


## Caso por antigüedad 

```{r}
media_mujeres <- aggregate(afil_mujeres$Salario, list(afil_mujeres$Antiguedad), FUN = mean)
media_hombres <- aggregate(afil_hombres$Salario, list(afil_hombres$Antiguedad), FUN = mean)
j <- 2
while (j <= nrow(media_mujeres)) {
  diferencia <- media_mujeres$Group.1[j] - media_mujeres$Group.1[j - 1]
  if (diferencia != 1) {
    m <- (media_mujeres$x[j] - media_mujeres$x[j - 1]) /
      (media_mujeres$Group.1[j] - media_mujeres$Group.1[j - 1])
    b <- media_mujeres$x[j] - m * media_mujeres$Group.1[j]
    edad_faltantes <- media_mujeres$Group.1[j - 1] + (1:(diferencia - 1))
    montos <- m * edad_faltantes + b
    faltantes <- data.frame(Group.1 = edad_faltantes, x = montos)
    media_mujeres <- rbind(media_mujeres[1:j - 1, ], faltantes, media_mujeres[j:nrow(media_mujeres), ])
  }
  j <- j + 1
}
j <- 2
while (j <= nrow(media_hombres)) {
  diferencia <- media_hombres$Group.1[j] - media_hombres$Group.1[j - 1]
  if (diferencia != 1) {
    m <- (media_hombres$x[j] - media_hombres$x[j - 1]) /
      (media_hombres$Group.1[j] - media_hombres$Group.1[j - 1])
    b <- media_hombres$x[j] - m * media_hombres$Group.1[j]
    edad_faltantes <- media_hombres$Group.1[j - 1] + (1:(diferencia - 1))
    montos <- m * edad_faltantes + b
    faltantes <- data.frame(Group.1 = edad_faltantes, x = montos)
    media_hombres <- rbind(media_hombres[1:j - 1, ], faltantes, media_hombres[j:nrow(media_hombres), ])
  }
  j <- j + 1
}

media_mujeres <- rbind(media_mujeres, data.frame(Group.1 = c(45, 46), x = rep(media_mujeres$x[nrow(media_mujeres)])))
escala_antiguedad <- data.frame(Antiguedad = 0:46, Hombres = media_hombres$x, Mujeres = media_mujeres$x)
min_h <- escala_antiguedad$Hombres[1]
min_m <- escala_antiguedad$Mujeres[1]
escala_antiguedad %<>% mutate(Hombres = Hombres / min_h, Mujeres = Mujeres / min_m)
write.csv(escala_antiguedad, "./Escala_antiguedad.csv", row.names = FALSE)
```


# Estadistica

```{r}
# Ejemplo esperanza de vida
Edad <- 30
exn(ListaDeTablasHombres[[Edad + 1]], x = Edad, type = "curtate")
```



# Estocástico


## Personal activo

Primero, se programa una función que calcula el salario de referencia para el cálculo de la pensión para una persona de edad $x$ empleada activa de la compañía dados:

-`antiguedad`: antigüedad a la edad $x$

-`salario`: salario a la edad $x$

-`k`: cantidad de **años** tras los cuáles la persona sufre algún decremento durante la vida laboral, es decir, a la edad $x+k$. Debe cumplir $k\leq 85 -x$ si la persona es hombre o $k\leq 77-x$ si la persona es mujer. 

Esta función se utiliza en el algortimo de Bacinello (1986) para calcular el salario de referencia una vez simulado que ocurre un decremeno en $k$ años.

```{r Funciones para calcular salarios de referencia}
salario_referencia <- function(antiguedad, salario, k){
  
  # k es el tiempo hasta que ocurre un decremento o se llega a la edad máxima de jubilación

  t <- max(-antiguedad, k - 4):k

  s <- (length(t) - 1):0

  salario_ref <- mean((1.025)^t * (1.04)^(t + s)) * 12 * salario  

  return(salario_ref)
}

salario_referencia_multiple <- function(antiguedad, salario, k) {
  return(sapply(X = k, FUN = salario_referencia, antiguedad = antiguedad, salario = salario))
}
```

Por ejemplo, si una persona de edad $50$ sufre algún decremento $2$ años despúes y tenía a la edad $50$ una antiguedad de $10$ años, entonces el salario de referencia, suponiendo un salario actual de $900,000$ para el cálculo de su pensión es

```{r Ejemplo funcionalidad salario_referencia}
salario_referencia(10, 900000, 2)
```

En segundo lugar, se crea una función que, dado un vector con la distribución de una variable aleatoria discreta $X$ que toma valores en un subconjunto finito de $\mathbb{N}\cup\{0\}$, es decir, un vector de la forma
\[
\bigg( \mathbb{P}(X=0),\mathbb{P}(X\leq 1), \mathbb{P}(X\leq 2),\mathbb{P}(X\leq 3),\dots\bigg),
\]
así como un número $0<p<1$, entonces retorna un valor $k\in\{0,1,2,\dots\}$ tal que

\[
\mathbb{P}(X\leq k-1)<p\leq \mathbb{P}(X\leq k),
\]

que corresponde al $p$-cuantil de $X$. Esta función se utiliza en el algortimo de Bacinello (1986) para hallar el momento de ocurrencia de algún decremento bajo el segundo criterio que plantea dicho método.

```{r Función para localizar cuantiles en modelo estocástico}
hallar_cuantil <- function(distribucion, p) {
  # if(p>max(distribucion)){k <- length(distribucion)-1}
  # else{}
  k <- min(which(p <= distribucion, arr.ind = TRUE))-1
  return(k)
}
```

<<<<<<< HEAD

```{r Función anualidad para modelo estocástico}
# Se crea una función para calcular el monto de los beneficios si ocurre un decremento tras k años y la persona vive t años adicionales
valor_anualidad <- function(k, t) {
    if(t==0){t=1}
    vectorMensual <- seq(1 / 12, t, 1 / 12)
    vectoraguinaldo <- c(rep(0, 10), 1, 0)
    vectorAnualmensual <- sort(rep(c(0:(t-1)), 12))
    MontoAPagar <- (1 + 0.04)^(vectorAnualmensual) * 2^vectoraguinaldo
    anualidad <- (v)^(vectorMensual)
    suma1 <- sum(anualidad * MontoAPagar)
    PV_aux <- suma1 * v^(k + 1)
    return(PV_aux)
  }
=======
```{r}
# # Pruebas de la función anterior, favor no borrar aún
x <- 42
qxs <- cbind(
    qxt(MDListaDeTablasHombres[[x + 1]], x = 0:115, t = 1, decrement = 1),
    qxt(MDListaDeTablasHombres[[x + 1]], x = 0:115, t = 1, decrement = 2),
    qxt(MDListaDeTablasHombres[[x + 1]], x = 0:115, t = 1, decrement = 3),
    qxt(MDListaDeTablasHombres[[x + 1]], x = 0:115, t = 1, decrement = 4),
    qxt(MDListaDeTablasHombres[[x + 1]], x = 0:115, t = 1)
  )

# dist <- 1-cumprod(1-qxs[(x+1):115,5])
dist <- qxt(MDListaDeTablasHombres[[x + 1]], x = x, t = 1:(85-x))

prob <- runif(1)

plot(0:(85-x-1), dist) + abline(h = prob, col="red") + abline(v = hallar_cuantil(dist, prob), col="red")

# rm(x, dist, prob, qxs)
>>>>>>> 6ba3a372075220e4d76191b12e557955a7d0da71
```



Para calcular los costos asociados a las personas afiliadas al plan ofrecido por la Compañía, se implementa una modificación de uno de los algortimos descritos en Bacinello (1988) bajo un modelo de múltiples decrementos. El mencionado algoritmo permite simular la variable aleatoria $W_{x}$ del tiempo (en años) de trabajo residual de un empleado activo de edad $(x)$. En esencia, el método proporciona un criterio para, en un primer paso y dada una muestra de una distribución $\mathcal{U}(0,1)$, decidir si una persona de edad $(x)$ se llega a jubilar obligatoriamente, en cuyo caso resta solamente simular su tiempo de vida residual. En su defecto, el algoritmo proporciona una regla para asignar, de acuerdo a una segunda muestra de una distribución $\mathcal{U}(0,1)$, cuál de los decrementos restantes sucedió para que no se llegara a la edad máxima de jubilación. Como puede comprobarse, el método requiere a lo sumo dos muestras provenientes de una distribución $\mathcal{U}(0,1)$ en aras de obtener una muestra de $W_{x}$.

Se programa primero la función `costo_afiliado_estocastico`, que retorna una simulación estocástica del costo que representa un afiliado con características:

-`x`: edad actual de la persona. 
-`sexo`: sexo de la persona. Debe estar codificado como "M" o como "F" representando, respectivamente, el sexo masculino o femenino.
-`salario`: salario actual (a la edad $x$)
-`antiguedad`: antigüedad actual de la persona en la Compañía (cantidad de años laborados en la Compañía a la edad $x$)
-`cant_simulaciones`: Cantidad de simulaciones a usar

Asimismo, esta función retorna un valor numérico correspondiente al cálculo del costo para el plan de la Compañía asociado a esta persona de acuerdo al método estocástico.



### Versión con simulación individual

```{r Modelo estocástico individual}


# N <- 10000
# i <- 40
# edad <- afil_mujeres$Edad[i]
# salario <- afil_mujeres$Salario[i]
# antiguedad <-afil_mujeres$Antiguedad[i]
# salarios <- rep(salario, 10)
# antiguedades <- rep(antiguedad, 10)
# edad_maxima <- 77
# lista_tablas_decrementos <- MDListaDeTablasMujeres
# lista_tablas_mortalidad <- ListaDeTablasMujeres
# cant_simulaciones <- N
```

```{r}

costo_estocastico_grupo_etario <- function(edad, salarios, edad_maxima, antiguedades, cant_simulaciones, lista_tablas_decrementos, lista_tablas_mortalidad) {
  x <- edad
  xi <- edad_maxima
  q4_prima <- lista_tablas_mortalidad[[x + 1]]
  qxs <- cbind(
    qxt(lista_tablas_decrementos[[x + 1]], x = x:xi, t = 1, decrement = 1),
    qxt(lista_tablas_decrementos[[x + 1]], x = x:xi, t = 1, decrement = 2),
    qxt(lista_tablas_decrementos[[x + 1]], x = x:xi, t = 1, decrement = 3),
    qxt(lista_tablas_decrementos[[x + 1]], x = x:xi, t = 1, decrement = 4),
    qxt(lista_tablas_decrementos[[x + 1]], x = x:xi, t = 1)
  )
  
  
  # Se define la distribución del modelo de múltiples decrementos (todas las causas)
  FWx <- qxt(lista_tablas_decrementos[[x + 1]], x = x, t = 1:(xi-x))
  # Se toman muestras uniformes en (0,1) según se especificó
  u <- runif(cant_simulaciones)
  
  # PRIMER CRITERIO
  # Cantidad de casos del primer criterio
  
  cant_pensiones_edad_maxima <- length(u[u > FWx[xi-x]])
  
  if (cant_pensiones_edad_maxima == 0) {
    costos_totales_edad_maxima <- 0
  } else {
    # Se simulan los tiempos residuales de vida (en años) para los pensionados de edad máxima (xi)
    tiempos_residuales_edad_maxima <- rLife(n = cant_pensiones_edad_maxima, object = q4_prima, x = xi, k = 1, type = "curtate")
    # Se calculan las anualidades mensuales prepagables según los años de vida restantes y con el periodo de diferimiento xi-x, así como los aguinaldos como una anualidad con el mismo periodo de diferimiento y de tipo inmediata (paga al final del año)
    anualidades_edad_maxima <- lapply(X = tiempos_residuales_edad_maxima, FUN = annuity, i = (0.07-0.04)/1.04, m = xi - x, k = 12, type = "due") %>% unlist()
    aguinaldo_edad_maxima <- lapply(X = tiempos_residuales_edad_maxima, FUN = annuity, i = (0.07-0.04)/1.04, m = xi - x, k = 1, type = "immediate") %>% unlist()
    pagos_edad_maxima <- anualidades_edad_maxima + aguinaldo_edad_maxima/12
    
    
    matriz_salarios_ref_edad_maxima <- mapply(salario_referencia_multiple, antiguedad = antiguedades, salario = salarios, MoreArgs = list(k = rep(xi-x, cant_pensiones_edad_maxima)))
    
    # Se calculan los porcentajes de pensión
    
    matriz_porcentajes_edad_maxima <- apply(X = outer(antiguedades, rep(xi - x, length(cant_pensiones_edad_maxima)), FUN = "+"), FUN = porcentaje_de_pension, MARGIN = 1)
    
    # Se calculan los costos por edad_maxima
    
    # Matriz con costos por escenario: Personas (columnas) y escenarios (filas)
    
    matriz_costos_edad_maxima <- matriz_porcentajes_edad_maxima * matriz_salarios_ref_edad_maxima * pagos_edad_maxima
    
    # Costos por persona: suma por columna de la matriz de costos
    if(is.matrix(matriz_costos_edad_maxima )){
    costos_edad_maxima_por_persona <-apply(X = matriz_costos_edad_maxima, MARGIN = 2, FUN = sum)
    }else{
      costos_edad_maxima_por_persona <- sapply(X = matriz_costos_edad_maxima, FUN = sum)
    }
    
    # Suma de los costos de todas las personas
    
    costos_totales_edad_maxima <- sum(costos_edad_maxima_por_persona)
  }
  
  # SEGUNDO CRITERIO: Decremento antes de jubilación
  
  if (cant_pensiones_edad_maxima < cant_simulaciones) { # esta condición significa que hay otros escenarios
    
    # Debe determinarse cuándo ocurrió el decremento y cuál fue
    # Primero se determina cuándo ocurrió, es decir, se buscan los cuantiles de la distribución de Wx que corresponden a las simulaciones U(0,1) restantes
    cuantiles <- lapply(X = u[u <= FWx[xi-x]], FUN = hallar_cuantil, distribucion = FWx) %>% unlist()
    # Se ajustan posicionalmente los cuantiles
    cuantiles <- cuantiles +1
    
    # Se calculan las probabilidades condicionales al momento de ocurrencia del decremento
    # Primero, se determinan los numeradores
    numeradores <- qxs[cuantiles, 1:4]
    # Segundo, se determinan los denominadores
    denominadores <-apply(X = numeradores, MARGIN = 1, FUN = sum) %>% unlist()
    denominadores[denominadores == 0] <- 1 # esto se hace para evitar indefiniciones
    # Tercero, se determinan las probabilidades condicionales dividiendo cada fila (numerador) entre el denominador respectivo
    probs_condicionales <- sweep(x = numeradores, MARGIN = 1, STATS = denominadores, FUN = "/")
    
    # Se determinan los escenarios en que ocurrió cada decremento
    
    # Primero, se tienen que simular nuevas muestras U(0,1) para los casos que no fueron incluidos en el primer criterio
    u <- runif(cant_simulaciones - cant_pensiones_edad_maxima)
    # Se determinan los extramemos de los intervalos de decisión
    extremos_intervalos <- apply(X = probs_condicionales, MARGIN = 1, FUN = cumsum) %>% t()
    
    
    # INVALIDEZ
    
     # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por invalidez
    casos_por_invalidez <- u<=extremos_intervalos[,1]
    posiciones_invalidez <- which(casos_por_invalidez , arr.ind = T)

        if (identical(posiciones_invalidez, integer(0))) {
      costos_totales_invalidez <- 0
    } else {
      # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
      tiempos_hasta_invalidez <- cuantiles[posiciones_invalidez]
      # Se simulan los tiempos residuales de vida
      tiempos_residuales_invalidez <- lapply(X = x + tiempos_hasta_invalidez, FUN = rLife, n = 1, object = q4_prima, k = 1, type = "curtate") %>% unlist()
      
      # Se calculan las anualidades correspondientes
      
      anualidades_invalidez <- mapply(annuity, i = (0.07-0.04)/1.04, n = tiempos_residuales_invalidez, m = tiempos_hasta_invalidez, k = 12, type = "due", SIMPLIFY = "vector")
      
      aguinaldos_invalidez <- mapply(annuity, i = (0.07-0.04)/1.04, n = tiempos_residuales_invalidez, m = tiempos_hasta_invalidez, k = 1, type = "immediate", SIMPLIFY = "vector")
      
      pagos_invalidez <- anualidades_invalidez + aguinaldos_invalidez/12
      
      # Se calculan los salarios de referencia en este caso
      
      matriz_salarios_ref_invalidez <- mapply(salario_referencia_multiple, antiguedad = antiguedades, salario = salarios, MoreArgs = list(k = tiempos_hasta_invalidez))
      
      # Se calculan los porcentajes de pensión
      
      matriz_porcentajes_invalidez <-apply(X = outer(antiguedades, tiempos_hasta_invalidez, FUN = "+"), FUN = porcentaje_de_pension, MARGIN = 1)
      
      # Se calculan los costos por invalidez
      
      # Matriz con costos por escenario: Personas (columnas) y escenarios (filas)
      
      matriz_costos_invalidez <- 0.6 * matriz_porcentajes_invalidez * matriz_salarios_ref_invalidez * pagos_invalidez
      
      # Costos por persona: suma por columna de la matriz de costos
      
      if(is.matrix(matriz_costos_invalidez)){
        costos_invalidez_por_persona <-apply(X = matriz_costos_invalidez, MARGIN = 2, FUN = sum)
      }else{
        costos_invalidez_por_persona <- sapply(X = matriz_costos_invalidez, FUN = sum)
      }
      
      # Suma de los costos de todas las personas
      
      costos_totales_invalidez <- sum(costos_invalidez_por_persona)
    }
    # JUBILACIÓN
    
    # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por jubilación
    
        casos_por_jubilacion <- extremos_intervalos[,1]<u & u<=extremos_intervalos[,2]
    posiciones_jubilacion <- which(casos_por_jubilacion, arr.ind = T)

    if (identical(posiciones_jubilacion, integer(0))) {
      costos_totales_jubilacion <- 0
    } else {
      # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
      tiempos_hasta_jubilacion <- cuantiles[posiciones_jubilacion]
      
      # Se simulan los tiempos residuales de vida
      tiempos_residuales_jubilacion <- lapply(X = x + tiempos_hasta_jubilacion, FUN = rLife, n = 1, object = q4_prima, k = 1, type = "curtate") %>% unlist()
      
      # Se calculan las anualidades correspondientes, incluyendo el aguinaldo
      anualidades_jubilacion <- mapply(annuity, i = (0.07-0.04)/1.04, n = tiempos_residuales_jubilacion, m = tiempos_hasta_jubilacion, k = 12, type = "due", SIMPLIFY = "vector")
      aguinaldos_jubilacion <- mapply(annuity, i = (0.07-0.04)/1.04, n = tiempos_residuales_jubilacion, m = tiempos_hasta_jubilacion, k = 1, type = "immediate", SIMPLIFY = "vector")
      pagos_jubilacion <- anualidades_jubilacion + aguinaldos_jubilacion/12
      
      # Se calculan los salarios de referencia en este caso
      
      matriz_salarios_ref_jubilacion <- mapply(salario_referencia_multiple, antiguedad = antiguedades, salario = salarios, MoreArgs = list(k = tiempos_hasta_jubilacion))
      
      # Se calculan los porcentajes de pensión
      
      matriz_porcentajes_jubilacion <-apply(X = outer(antiguedades, tiempos_hasta_jubilacion, FUN = "+"), FUN = porcentaje_de_pension, MARGIN = 1)
      
      # Se calculan los costos por jubilacion
      
      # Matriz con costos por escenario: Personas (columnas) y escenarios (filas)
      
      matriz_costos_jubilacion <- matriz_porcentajes_jubilacion * matriz_salarios_ref_jubilacion * pagos_jubilacion
      
      # Costos por persona: suma por columna de la matriz de costos
      
      if(is.matrix(matriz_costos_jubilacion)){
        costos_jubilacion_por_persona <-apply(X = matriz_costos_jubilacion, MARGIN = 2, FUN = sum)
        }
      else{
          
          costos_jubilacion_por_persona <- sapply(X = matriz_costos_jubilacion, FUN = sum)
        }
      
      # Suma de los costos de todas las personas
      
      costos_totales_jubilacion <- sum(costos_jubilacion_por_persona)
    }
    
    # RETIRO

    # No es necesario calcular nada ya que no les otorga pensión
    
    # MUERTE
    
    # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por muerte
    
    casos_por_muerte <-extremos_intervalos[,3]<u
    posiciones_muerte <- which(casos_por_muerte, arr.ind = T)
    
    if (identical(posiciones_muerte, integer(0))) {
      costos_totales_muerte <- 0
    } else {
      # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
      
      tiempos_hasta_muerte <- cuantiles[posiciones_muerte]
      
      # Se calculan las anualidades a 10 años correspondientes incluyendo el aguinaldo
      anualidades_muerte <- mapply(annuity, i = (0.07-0.04)/1.04, n = 10, m = tiempos_hasta_muerte, k = 12, type = "due", SIMPLIFY = "vector")
      aguinaldos_muerte <- mapply(annuity, i = (0.07-0.04)/1.04, n = 10, m = tiempos_hasta_muerte, k = 1, type = "immediate", SIMPLIFY = "vector")
      pagos_muerte <- anualidades_muerte + aguinaldos_muerte/12
      
      # Se calculan los salarios de referencia en este caso
      
      matriz_salarios_ref_muerte <- mapply(salario_referencia_multiple, antiguedad = antiguedades, salario = salarios, MoreArgs = list(k = tiempos_hasta_muerte))
      
      # Se calculan los porcentajes de pensión
      
      matriz_porcentajes_muerte <-apply(X = outer(antiguedades, tiempos_hasta_muerte, FUN = "+"), FUN = porcentaje_de_pension, MARGIN = 1)
      
      # Se calculan los costos por muerte
      
      # Matriz con costos por escenario: Personas (columnas) y escenarios (filas)
      
      matriz_costos_muerte <- 0.2 * matriz_porcentajes_muerte * matriz_salarios_ref_muerte * pagos_muerte
      
      # Costos por persona: suma por columna de la matriz de costos
      if(is.matrix(matriz_costos_muerte)){
        costos_muerte_por_persona <-apply(X = matriz_costos_muerte, MARGIN = 2, FUN = sum)}
      else{
        costos_muerte_por_persona <- sapply(X = matriz_costos_muerte, FUN = sum)
        
      }
      
      # Suma de los costos de todas las personas
      
      costos_totales_muerte <- sum(costos_muerte_por_persona)
    }
  }
  # RETORNAR LOS COSTOS TOTALES
  
  return(sum(costos_totales_edad_maxima, costos_totales_invalidez, costos_totales_jubilacion, costos_totales_muerte) / cant_simulaciones)
}
```

```{r Prueba estocástico por grupo etario}
set.seed(10)
N <- 100000
t <- proc.time()
# Costo hombres (Joshua)
i<-1
for (edad in unique(sort(afil_hombres$Edad))) {
print(paste("Hombres de ", edad, "años"))
costos_hombres <- 1:length(unique(afil_hombres$Edad))
datos <- afil_hombres %>% filter(Edad == edad) %>% select(Salario, Antiguedad)
salarios <- datos$Salario
antiguedades <- datos$Antiguedad
costos_hombres[i] <- costo_estocastico_grupo_etario(edad, salarios, 85, antiguedades, N, MDListaDeTablasHombres, ListaDeTablasHombres)
print(costos_hombres[i])
i <- i+1
}
proc.time()-t
archivo <- file("Resultados estocástico grupal Hombres 100000.txt")
writeLines(paste("Estocastico:", "Hombres", sum(costos_hombres)), archivo)
close(archivo)

# Costo mujeres (Moisés)
i<-1
t <- proc.time()
for (edad in unique(sort(afil_mujeres$Edad))) {
print(paste("Mujeres de ", edad, "años"))
costos_mujeres <- 1:length(unique(afil_mujeres$Edad))
datos <- afil_mujeres %>% filter(Edad == edad) %>% select(Salario, Antiguedad)
salarios <- datos$Salario
antiguedades <- datos$Antiguedad
costos_mujeres[i] <- costo_estocastico_grupo_etario(edad, salarios, 77, antiguedades, N, MDListaDeTablasMujeres, ListaDeTablasMujeres)
print(costos_mujeres[i])
i <- i+1
}
proc.time()-t
archivo <- file("Resultados estocástico grupal Mujeres 100000.txt")
writeLines(paste("Estocastico:", "Mujeres", sum(costos_mujeres)), archivo)
close(archivo)



# archivo <- file("Resultados Estocástico por grupo de edad 10000.txt")
# writeLines(paste("Estocastico:", "Mujeres", sum(costos_mujeres), "Hombres", sum(costos_hombres), sep = " "), archivo)
# close(archivo)
# # 

# datos <- afil_hombres %>% filter(Edad == x) %>% select(Salario, Antiguedad)
# salarios <- datos$Salario
# antiguedades <- datos$Antiguedad
# 
# # Edad máxima de jubilacion
x <- afil_hombres$Edad[1]
xi <- 85
salario <- afil_hombres$Salario[1]
antiguedad <- afil_hombres$Antiguedad[1]
cant_simulaciones <- 10000
lista_tablas_decrementos <- MDListaDeTablasHombres
lista_tablas_mortalidad <- ListaDeTablasHombres
# # Vector de probabilidades de muerte simples
# # q4_prima <- ListaDeTablasMujeres[[x+1]]
# # Vector con probabilidades (q1, q2, q3, q4, q_Tau)
#  # qxs <- cbind(qxt(MDListaDeTablasMujeres[[x+1]], x=0:115, t=1, decrement=1),
#  #         qxt(MDListaDeTablasMujeres[[x+1]], x=0:115, t=1, decrement=2),
#  #         qxt(MDListaDeTablasMujeres[[x+1]], x=0:115, t=1, decrement=3),
#  #         qxt(MDListaDeTablasMujeres[[x+1]], x=0:115, t=1, decrement=4),
#  #         qxt(MDListaDeTablasMujeres[[x+1]], x=0:115, t=1))
# 
# costo_estocastico_grupo_etario(x, salarios, xi, antiguedades, 50000, MDListaDeTablasHombres, ListaDeTablasHombres)
```

```{r}
set.seed(10000)
N <- 10000
i <- 1
edad <- afil_mujeres$Edad[i]
salario <- afil_mujeres$Salario[i]
antiguedad <-afil_mujeres$Antiguedad[i]
costo_afiliado_estocastico(edad,
                           salario,
                           77,
                           antiguedad,
                           cant_simulaciones = N,
                           MDListaDeTablasMujeres,
                           ListaDeTablasMujeres)


N <- 10000
i <- 1
edad <- afil_hombres$Edad[i]
salario <- afil_hombres$Salario[i]
antiguedad <-afil_hombres$Antiguedad[i]
costo_afiliado_estocastico(edad,
                           salario,
                           85,
                           antiguedad,
                           cant_simulaciones = N,
                           MDListaDeTablasHombres,
                           ListaDeTablasHombres)
# set.seed(10000)
# salarios <- rep(salario, 100)
# antiguedades <- rep(antiguedad, 100)
# costo_estocastico_grupo_etario(edad,
#                            salarios,
#                            77,
#                            antiguedades,
#                            cant_simulaciones = N,
#                            MDListaDeTablasMujeres,
#                            ListaDeTablasMujeres)/100
```

### Versión con simulación individual

```{r}
costo_afiliado_estocastico <- function(edad, salario, edad_maxima, antiguedad, cant_simulaciones, lista_tablas_decrementos, lista_tablas_mortalidad) {
  x <- edad
  xi <- edad_maxima
  q4_prima <- lista_tablas_mortalidad[[x + 1]]
  v <- 1/1.07

  # Se define la distribución del modelo de múltiples decrementos (todas las causas)
  FWx <- qxt(lista_tablas_decrementos[[x + 1]], x = x, t = 1:(xi-x))
  # Se toman muestras uniformes en (0,1) según se especificó

  u <- runif(cant_simulaciones)  
  # PRIMER CRITERIO: Jubilación obligatoria
  # Se cuenta la cantidad escenarios en que ocurrió esta condición: Se comprueba u>FWx(xi-x-1) (se tiene que correr el índice)
  cant_pensiones_edad_maxima <- length(u[u > FWx[xi-x]])

  if(cant_pensiones_edad_maxima==0){

    costos_edad_maxima <- 0
  }else{
    # Se calcula el salario de referencia en este caso
    salario_ref_edad_maxima <- salario_referencia(antiguedad, salario, xi-x)
    # Se simulan los tiempos residuales de vida (en años) para los pensionados de edad máxima (xi)
    tiempos_residuales_edad_maxima <- rLife(n=cant_pensiones_edad_maxima, object = q4_prima, x=xi, k = 1, type = "curtate")
    # Se calculan las anualidades mensuales
    pagos_edad_maxima <- sapply(X=tiempos_residuales_edad_maxima, FUN=valor_anualidad, k=xi-x)/12 

  # Se calculan los costos asociados al primer criterio del algoritmo
    costos_edad_maxima <- salario_ref_edad_maxima * pagos_edad_maxima
  }
  # SEGUNDO CRITERIO: Decremento antes de jubilación por edad máxima
  if(cant_pensiones_edad_maxima<cant_simulaciones){# esta condición significa que hay otros escenarios
      # Debe determinarse cuándo ocurrió el decremento y cuál fue
    # Primero se determina cuándo ocurrió, es decir, se buscan los cuantiles de la distribución de Wx que corresponden a las simulaciones U(0,1) restantes
    cuantiles <- lapply(X = u[u <= FWx[xi-x]], FUN = hallar_cuantil, distribucion = FWx) %>% unlist() 

    # Se calculan las probabilidades condicionales al momento de ocurrencia del decremento
    # Se calculan las probabilidades condicionales al momento de ocurrencia del decremento
    # Primero, se determinan los numeradores
    numeradores <- cbind(
    qxt(lista_tablas_decrementos[[x + 1]], x = x+cuantiles, t = 1, decrement = 1),
    qxt(lista_tablas_decrementos[[x + 1]], x = x+cuantiles, t = 1, decrement = 2),
    qxt(lista_tablas_decrementos[[x + 1]], x = x+cuantiles, t = 1, decrement = 3),
    qxt(lista_tablas_decrementos[[x + 1]], x = x+cuantiles, t = 1, decrement = 4)
  )

    # Se calculan las probabilidades condicionales al momento de ocurrencia del decremento
    # Primero, se determinan los numeradores
    numeradores <- qxs[cuantiles,1:4]
    # Segundo, se determinan los denominadores
    denominadores <- apply(X = numeradores, MARGIN = 1, FUN=sum) %>% unlist()
    denominadores[denominadores==0] <- 1 # Para evitar indefiniciones
    # Tercero, se determinan las probabilidades condicionales dividiendo cada fila (numerador) entre el denominador respectivo
    probs_condicionales <- sweep(x=numeradores, MARGIN = 1, STATS = denominadores, FUN = '/' )
    
    # Se determinan los escenarios en que ocurrió cada decremento
    
    # Primero, se tienen que simular nuevas muestras U(0,1) para los casos que no fueron incluidos en el primer criterio
    u <- runif(cant_simulaciones-cant_pensiones_edad_maxima)
    # Se determinan los extramemos de los intervalos de decisión
    extremos_intervalos <- apply(X = probs_condicionales, MARGIN = 1, FUN = cumsum) %>% t()
    
    # INVALIDEZ
    # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por invalidez
    casos_por_invalidez <- u<=extremos_intervalos[,1]
    posiciones_invalidez <- which(casos_por_invalidez , arr.ind = T)
    if(identical(posiciones_invalidez, integer(0))){
      costos_invalidez <- 0
    }else{
      # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
      tiempos_hasta_invalidez <- cuantiles[posiciones_invalidez]
      # Se simulan los tiempos residuales de vida
      tiempos_residuales_invalidez <- lapply(X = x+tiempos_hasta_invalidez, FUN = rLife, n=1, object = q4_prima, k = 1, type = "curtate") %>% unlist()
      
      # Se calculan las anualidades correspondientes

      pagos_invalidez <- mapply(FUN=valor_anualidad, k=tiempos_hasta_invalidez, t=tiempos_residuales_invalidez)/12
      
      # Se calculan los salarios de referencia en este caso
      salarios_ref_invalidez <- lapply(X=tiempos_hasta_invalidez, FUN = salario_referencia, antiguedad=antiguedad, salario=salario) %>% unlist()
      # Se calculan los porcentajes de pensión
      porcentajes_invalidez <- lapply(X=antiguedad+tiempos_hasta_invalidez, FUN=porcentaje_de_pension) %>% unlist()
      # Se calculan los costos por invalidez
      costos_invalidez <- 0.6 * porcentajes_invalidez * salarios_ref_invalidez * pagos_invalidez
    }
    # JUBILACIÓN
    
    # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por jubilación
    casos_por_jubilacion <- extremos_intervalos[,1]<u & u <=extremos_intervalos[,2]
    posiciones_jubilacion <- which(casos_por_jubilacion, arr.ind = T)

    if(identical(posiciones_jubilacion, integer(0))){
      costos_jubilacion <- 0
    }else{
      # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
      tiempos_hasta_jubilacion <- cuantiles[posiciones_jubilacion] 
      
      # Se simulan los tiempos residuales de vida
      tiempos_residuales_jubilacion <- lapply(X = x+tiempos_hasta_jubilacion, FUN = rLife, n=1, object = q4_prima, k = 1, type = "curtate") %>% unlist()
      # Se calculan las anualidades correspondientes
      pagos_jubilacion <- mapply(FUN=valor_anualidad, k=tiempos_hasta_jubilacion, t=tiempos_residuales_jubilacion)/12

      # Se calculan los salarios de referencia en este caso
      salarios_ref_jubilacion <- lapply(X=tiempos_hasta_jubilacion, FUN = salario_referencia, antiguedad=antiguedad, salario=salario) %>% unlist()
      # Se calculan los porcentajes de pensión
      porcentajes_jubilacion <- lapply(X=antiguedad+tiempos_hasta_jubilacion, FUN=porcentaje_de_pension) %>% unlist()
      # Se calculan los costos por jubilacion
      costos_jubilacion <- porcentajes_jubilacion * salarios_ref_jubilacion*pagos_jubilacion
      
    }
    
    # RETIRO
    # casos_por_retiro <- extremos_intervalos[,2]<u & u<=extremos_intervalos[,3]

    # No es necesario calcular nada ya que no les otorga pensión
    
    # MUERTE
    
    # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por muerte
    casos_por_muerte <-extremos_intervalos[,3]<u
    posiciones_muerte <- which(casos_por_muerte, arr.ind = T)
    
    if(identical( posiciones_muerte, integer(0))){
      tiempos_hasta_muerte<-0
    }else{
      # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
      tiempos_hasta_muerte <- cuantiles[posiciones_muerte] 
      # Se calculan las anualidades a 10 años correspondientes
      pagos_muerte <- sapply(X=tiempos_hasta_muerte,FUN=valor_anualidad, t=10)/12
      # Se calculan los salarios de referencia en este caso
      salarios_ref_muerte <- lapply(X=tiempos_hasta_muerte, FUN = salario_referencia, antiguedad=antiguedad, salario=salario) %>% unlist()
      # Se calculan los porcentajes de pensión
      porcentajes_muerte <- lapply(X=antiguedad+tiempos_hasta_muerte, FUN=porcentaje_de_pension) %>% unlist()
      # Se calculan los costos por muerte
      costos_muerte <- 0.2 * porcentajes_muerte * salarios_ref_muerte * pagos_muerte
      
    }
    
  }

  costos_totales_invalidez <- sum(costos_invalidez)/cant_simulaciones
  costos_totales_jubilacion <- sum(costos_jubilacion, costos_edad_maxima)/cant_simulaciones
  costos_totales_muerte <- sum(costos_muerte)/cant_simulaciones
  costos <- c(costos_totales_invalidez, costos_totales_jubilacion, costos_totales_muerte,costos_totales_invalidez+costos_totales_jubilacion+costos_totales_muerte )
    return(costos)

  }

```

```{r Pruebas estocástico individual}
set.seed(10)
N <- 10000

# MUJERES INDIVIDUAL (Leonardo)

t <- proc.time()
costos_mujeres <- 1:nrow(afil_mujeres)
for (i in 1:nrow(afil_mujeres)) {
edad <- afil_mujeres$Edad[i]
salario <- afil_mujeres$Salario[i]
antiguedad <-afil_mujeres$Antiguedad[i]
costos_mujeres[i] <- costo_afiliado_estocastico(edad, 
                                             salario, 
                                             77,
                                             antiguedad, 
                                             cant_simulaciones = N,
                                             MDListaDeTablasMujeres, 
                                             ListaDeTablasMujeres)
print(i)  
}
proc.time()-t
archivo <- file("Resultados estocástico individual Mujeres 10000.txt")
writeLines(paste("Estocastico:", "Mujeres", sum(costos_mujeres)), archivo)
close(archivo)

# HOMBRES INDIVIDUAL (Daniel)
t <- proc.time()
costos_hombres <- 1:nrow(afil_hombres)
for (i in 1:nrow(afil_hombres)) {
edad <- afil_hombres$Edad[i]
salario <- afil_hombres$Salario[i]
antiguedad <-afil_hombres$Antiguedad[i]
costos_hombres[i] <- costo_afiliado_estocastico(edad, 
                                             salario, 
                                             85,
                                             antiguedad, 
                                             cant_simulaciones = N,
                                             MDListaDeTablasHombres, 
                                             ListaDeTablasHombres)
print(i)
}
archivo <- file("Resultados estocástico individual Hombres 10000.txt")
writeLines(paste("Estocastico:", "Hombres", sum(costos_hombres)), archivo)
close(archivo)
proc.time()-t
# t <- proc.time()
# costos_mujeres <- mapply(FUN = costo_afiliado_estocastico,
#                         edad= afil_mujeres$Edad, 
#                                    salario=afil_mujeres$Salario,
#                                    antiguedad=afil_mujeres$Antiguedad,
#                         MoreArgs = list(edad_maxima=77,
#                                         cant_simulaciones=N,                lista_tablas_decrementos=MDListaDeTablasMujeres,
#                                         lista_tablas_mortalidad=ListaDeTablasMujeres),
#                         SIMPLIFY = "vector")
# costos_hombres <- mapply(FUN = costo_afiliado_estocastico,
#                         edad= afil_hombres$Edad, 
#                                    salario=afil_hombres$Salario,
#                                    antiguedad=afil_hombres$Antiguedad,
#                         MoreArgs = list(edad_maxima=85,
#                                         cant_simulaciones=N,                                     
#                                         lista_tablas_decrementos=MDListaDeTablasHombres,
#                                         lista_tablas_mortalidad=ListaDeTablasHombres),
#                         SIMPLIFY = "vector")
# proc.time()-t
# archivo <- file("Resultados Estocástico por persona 100.txt")
# writeLines(paste("Estocastico:", "Mujeres", sum(costos_mujeres), "Hombres", sum(costos_hombres), sep = " "), archivo)
# close(archivo)

# costo_afiliado_estocastico(edad = 50, salario = 10000000, edad_maxima = 85, antiguedad = 10, cant_simulaciones = 50, lista_tablas_decrementos = MDListaDeTablasHombres, lista_tablas_mortalidad = ListaDeTablasHombres)

```


### Versión con simulación por grupos de edad



```{r Modelo estocástico por grupos de edad}

costo_afiliado_estocastico_grupo_etario <- function(edad, salarios, edad_maxima, antiguedades, cant_simulaciones, lista_tablas_decrementos, lista_tablas_mortalidad) {
  v <- 1/(1.07)
  x <- edad
  xi <- edad_maxima
  q4_prima <- lista_tablas_mortalidad[[x + 1]]
  # Se define la distribución del modelo de múltiples decrementos (todas las causas)
  FWx <- qxt(lista_tablas_decrementos[[x + 1]], x = x, t = 1:(xi-x))
  # Se toman muestras uniformes en (0,1) según se especificó
  u <- runif(cant_simulaciones)
  # PRIMER CRITERIO
  # Cantidad de casos del primer criterio
  cant_pensiones_edad_maxima <- length(u[u > FWx[xi-x]])
  if (cant_pensiones_edad_maxima == 0) {
    costos_totales_edad_maxima <- 0
  } else {
    # Se simulan los tiempos residuales de vida (en años) para los pensionados de edad máxima (xi)
    tiempos_residuales_edad_maxima <- rLife(n = cant_pensiones_edad_maxima, object = q4_prima, x = xi, k = 1, type = "curtate")
    # Se calculan las anualidades mensuales
    pagos_edad_maxima <- sapply(X=tiempos_residuales_edad_maxima, FUN=valor_anualidad, k=xi-x)/12
    # Se calcula la matriz de salarios
    matriz_salarios_ref_edad_maxima <- mapply(salario_referencia_multiple, antiguedad = antiguedades, salario = salarios, MoreArgs = list(k = rep(xi-x, cant_pensiones_edad_maxima)))
    
    # Se calculan los porcentajes de pensión
    matriz_porcentajes_edad_maxima <- apply(X = outer(antiguedades, rep(xi - x, length(cant_pensiones_edad_maxima)), FUN = "+"), FUN = porcentaje_de_pension, MARGIN = 1)
    
    # Se calculan los costos por edad_maxima
    
    # Matriz con costos por escenario: Personas (columnas) y escenarios (filas)
    
    matriz_costos_edad_maxima <- matriz_porcentajes_edad_maxima * matriz_salarios_ref_edad_maxima * pagos_edad_maxima
    
    # Costos por persona: suma por columna de la matriz de costos
    if(is.matrix(matriz_costos_edad_maxima )){
    costos_edad_maxima_por_persona <-apply(X = matriz_costos_edad_maxima, MARGIN = 2, FUN = sum)
    }else{
      costos_edad_maxima_por_persona <- sapply(X = matriz_costos_edad_maxima, FUN = sum)
    }
    # Suma de los costos de todas las personas
    costos_totales_edad_maxima <- sum(costos_edad_maxima_por_persona)/cant_simulaciones
  }
  # SEGUNDO CRITERIO: Decremento antes de jubilación
  if (cant_pensiones_edad_maxima < cant_simulaciones) { # esta condición significa que hay otros escenarios
    
    # Debe determinarse cuándo ocurrió el decremento y cuál fue
    # Primero se determina cuándo ocurrió, es decir, se buscan los cuantiles de la distribución de Wx que corresponden a las simulaciones U(0,1) restantes
    cuantiles <- lapply(X = u[u <= FWx[xi-x]], FUN = hallar_cuantil, distribucion = FWx) %>% unlist()
    # Se calculan las probabilidades condicionales al momento de ocurrencia del decremento
    # Primero, se determinan los numeradores
    numeradores <- cbind(
    qxt(lista_tablas_decrementos[[x + 1]], x = x+cuantiles, t = 1, decrement = 1),
    qxt(lista_tablas_decrementos[[x + 1]], x = x+cuantiles, t = 1, decrement = 2),
    qxt(lista_tablas_decrementos[[x + 1]], x = x+cuantiles, t = 1, decrement = 3),
    qxt(lista_tablas_decrementos[[x + 1]], x = x+cuantiles, t = 1, decrement = 4)
  )
    # Segundo, se determinan los denominadores
    denominadores <-apply(X = numeradores, MARGIN = 1, FUN = sum) %>% unlist()
    denominadores[denominadores == 0] <- 1 # esto se hace para evitar indefiniciones
    # Tercero, se determinan las probabilidades condicionales dividiendo cada fila (numerador) entre el denominador respectivo
    probs_condicionales <- sweep(x = numeradores, MARGIN = 1, STATS = denominadores, FUN = "/")
    
    # Se determinan los escenarios en que ocurrió cada decremento
    
    # Primero, se tienen que simular nuevas muestras U(0,1) para los casos que no fueron incluidos en el primer criterio
    u <- runif(cant_simulaciones - cant_pensiones_edad_maxima)
    # Se determinan los extramemos de los intervalos de decisión
    extremos_intervalos <- apply(X = probs_condicionales, MARGIN = 1, FUN = cumsum) %>% t()
    
    
    # INVALIDEZ
    
     # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por invalidez
    casos_por_invalidez <- u<=extremos_intervalos[,1]
    posiciones_invalidez <- which(casos_por_invalidez , arr.ind = T)

    if (identical(posiciones_invalidez, integer(0))) {
      costos_totales_invalidez <- 0
    } else {
      # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
      tiempos_hasta_invalidez <- cuantiles[posiciones_invalidez]
      # Se simulan los tiempos residuales de vida
      tiempos_residuales_invalidez <- lapply(X = x + tiempos_hasta_invalidez, FUN = rLife, n = 1, object = q4_prima, k = 1, type = "curtate") %>% unlist()
      
      # Se calculan las anualidades correspondientes
     
       pagos_invalidez <- mapply(FUN=valor_anualidad, k=tiempos_hasta_invalidez, t=tiempos_residuales_invalidez)/12
      
      # Se calculan los salarios de referencia en este caso
      
      matriz_salarios_ref_invalidez <- mapply(salario_referencia_multiple, antiguedad = antiguedades, salario = salarios, MoreArgs = list(k = tiempos_hasta_invalidez))
      
      # Se calculan los porcentajes de pensión
      
      matriz_porcentajes_invalidez <-apply(X = outer(antiguedades, tiempos_hasta_invalidez, FUN = "+"), FUN = porcentaje_de_pension, MARGIN = 1)
      
      # Se calculan los costos por invalidez
      
      # Matriz con costos por escenario: Personas (columnas) y escenarios (filas)
      
      matriz_costos_invalidez <- 0.6 * matriz_porcentajes_invalidez * matriz_salarios_ref_invalidez * pagos_invalidez
      
      # Costos por persona: suma por columna de la matriz de costos
      
      if(is.matrix(matriz_costos_invalidez)){
        costos_invalidez_por_persona <-apply(X = matriz_costos_invalidez, MARGIN = 2, FUN = sum)
      }else{
        costos_invalidez_por_persona <- sapply(X = matriz_costos_invalidez, FUN = sum)
      }
      
      # Suma de los costos de todas las personas
      
      costos_totales_invalidez <- sum(costos_invalidez_por_persona)/cant_simulaciones
    }
    # JUBILACIÓN
    
    # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por jubilación
    
        casos_por_jubilacion <- extremos_intervalos[,1]<u & u<=extremos_intervalos[,2]
    posiciones_jubilacion <- which(casos_por_jubilacion, arr.ind = T)

    if (identical(posiciones_jubilacion, integer(0))) {
      costos_totales_jubilacion <- 0
    } else {
      # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
      tiempos_hasta_jubilacion <- cuantiles[posiciones_jubilacion]
      
      # Se simulan los tiempos residuales de vida
      tiempos_residuales_jubilacion <- lapply(X = x + tiempos_hasta_jubilacion, FUN = rLife, n = 1, object = q4_prima, k = 1, type = "curtate") %>% unlist()
      
      # Se calculan las anualidades correspondientes
      pagos_jubilacion <- mapply(FUN=valor_anualidad, k=tiempos_hasta_jubilacion, t=tiempos_residuales_jubilacion)/12
      # Se calculan los salarios de referencia en este caso
      
      matriz_salarios_ref_jubilacion <- mapply(salario_referencia_multiple, antiguedad = antiguedades, salario = salarios, MoreArgs = list(k = tiempos_hasta_jubilacion))
      
      # Se calculan los porcentajes de pensión
      
      matriz_porcentajes_jubilacion <-apply(X = outer(antiguedades, tiempos_hasta_jubilacion, FUN = "+"), FUN = porcentaje_de_pension, MARGIN = 1)
      
      # Se calculan los costos por jubilacion
      
      # Matriz con costos por escenario: Personas (columnas) y escenarios (filas)
      
      matriz_costos_jubilacion <- matriz_porcentajes_jubilacion * matriz_salarios_ref_jubilacion * pagos_jubilacion
      
      # Costos por persona: suma por columna de la matriz de costos
      
      if(is.matrix(matriz_costos_jubilacion)){
        costos_jubilacion_por_persona <-apply(X = matriz_costos_jubilacion, MARGIN = 2, FUN = sum)
        }else{
          
          costos_jubilacion_por_persona <- sapply(X = matriz_costos_jubilacion, FUN = sum)
        }
      
      # Suma de los costos de todas las personas
      
      costos_totales_jubilacion <- sum(costos_jubilacion_por_persona)/cant_simulaciones
    }
    
    # RETIRO

    # No es necesario calcular nada ya que no les otorga pensión
    
    # MUERTE
    
    # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por muerte
    
    casos_por_muerte <-extremos_intervalos[,3]<u
    posiciones_muerte <- which(casos_por_muerte, arr.ind = T)
    
    if (identical(posiciones_muerte, integer(0))) {
      costos_totales_muerte <- 0
    } else {
     # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
      
      tiempos_hasta_muerte <- cuantiles[posiciones_muerte]
      
     # Se calculan las anualidades a 10 años correspondientes
      pagos_muerte <- sapply(X=tiempos_hasta_muerte,FUN=valor_anualidad, t=10)/12
      # Se calculan los salarios de referencia en este caso
      
      matriz_salarios_ref_muerte <- mapply(salario_referencia_multiple, antiguedad = antiguedades, salario = salarios, MoreArgs = list(k = tiempos_hasta_muerte))
      
      # Se calculan los porcentajes de pensión
      
      matriz_porcentajes_muerte <-apply(X = outer(antiguedades, tiempos_hasta_muerte, FUN = "+"), FUN = porcentaje_de_pension, MARGIN = 1)
      
      # Se calculan los costos por muerte
      
      # Matriz con costos por escenario: Personas (columnas) y escenarios (filas)
      
      matriz_costos_muerte <- 0.2 * matriz_porcentajes_muerte * matriz_salarios_ref_muerte * pagos_muerte
      
      # Costos por persona: suma por columna de la matriz de costos
      if(is.matrix(matriz_costos_muerte)){
        costos_muerte_por_persona <-apply(X = matriz_costos_muerte, MARGIN = 2, FUN = sum)}
      else{
        costos_muerte_por_persona <- sapply(X = matriz_costos_muerte, FUN = sum)
        
      }
      
      # Suma de los costos de todas las personas
      
      costos_totales_muerte <- sum(costos_muerte_por_persona)/cant_simulaciones
    }
  }
  # RETORNAR LOS COSTOS TOTALES
  costos_totales <- costos_totales_invalidez+
    costos_totales_edad_maxima+
    costos_totales_jubilacion+
    costos_totales_muerte

  return(c(costos_totales_invalidez+costos_totales_edad_maxima, costos_totales_jubilacion, costos_totales_muerte, costos_totales ))
}
```

```{r Verificación equivalencia individual-grupal}
# N <- 1000
i <- 1
edad <- afil_mujeres$Edad[i]
# salario <- afil_mujeres$Salario[i]
# antiguedad <-afil_mujeres$Antiguedad[i]
# salarios <- rep(salario, 2)
# antiguedades <- rep(antiguedad, 2)
# edad_maxima <- 77
# lista_tablas_decrementos <- MDListaDeTablasMujeres
# lista_tablas_mortalidad <- ListaDeTablasMujeres
# cant_simulaciones <- N
# set.seed(10)
# costo_afiliado_estocastico_grupo_etario(edad, salarios, edad_maxima, antiguedades, cant_simulaciones, lista_tablas_decrementos, lista_tablas_mortalidad)
# set.seed(10)
# costo_afiliado_estocastico(edad, salario, edad_maxima, antiguedad, cant_simulaciones, lista_tablas_decrementos, lista_tablas_mortalidad)

N<-10000
posiciones46 <- which(afil_mujeres$Edad==46, arr.ind = T)

datos <- afil_mujeres %>% filter(Edad == edad) %>% select(Salario, Antiguedad)
salarios <- datos$Salario
antiguedades <- datos$Antiguedad
costos46 <- costo_afiliado_estocastico_grupo_etario(edad, salarios, 77, antiguedades, N, MDListaDeTablasMujeres, ListaDeTablasMujeres)

sum(salida_total_mujeres[posiciones46 ])

```

```{r Prueba estocástico por grupo etario}
set.seed(10)
N <- 100000
t <- proc.time()
# Costo hombres (Leonardo)
i<-1
costos_grupal_estoc_h <- matrix(0, nrow = length(unique(afil_hombres$Edad)), ncol=4)
for (edad in unique(sort(afil_hombres$Edad))) {
print(paste("Hombres de ", edad, "años"))

datos <- afil_hombres %>% filter(Edad == edad) %>% select(Salario, Antiguedad)
salarios <- datos$Salario
antiguedades <- datos$Antiguedad
costos_grupal_estoc_h[i,] <- costo_afiliado_estocastico_grupo_etario(edad, salarios, 85, antiguedades, N, MDListaDeTablasHombres, ListaDeTablasHombres)
print(costos_grupal_estoc_h[i,4])
i <- i+1
}
proc.time()-t
costos_grupal_estoc_h <- as.data.frame(costos_grupal_estoc_h)
colnames(costos_grupal_estoc_h) <- c("Invalidez", "Jubilación", "Muerte", "Total")
write.csv(costos_grupal_estoc_h,"Costos estocástico hombres por grupo etario.csv", row.names = FALSE)

# Costo mujeres (Joshua)

N <- 100000
costos_grupal_estoc_m <- matrix(NA, nrow = length(unique(afil_mujeres$Edad)), ncol=4)
i<-1
t <- proc.time()
for (edad in unique(sort(afil_mujeres$Edad))) {
print(paste("Mujeres de ", edad, "años"))
datos <- afil_mujeres %>% filter(Edad == edad) %>% select(Salario, Antiguedad)
salarios <- datos$Salario
antiguedades <- datos$Antiguedad
costos_grupal_estoc_m[i,] <- costo_afiliado_estocastico_grupo_etario(edad, salarios, 77, antiguedades, N, MDListaDeTablasMujeres, ListaDeTablasMujeres)
print(costos_grupal_estoc_m[i,4])
i <- i+1
}
proc.time()-t
costos_grupal_estoc_h <- as.data.frame(costos_grupal_estoc_m)
colnames(costos_grupal_estoc_h) <- c("Invalidez", "Jubilación", "Muerte", "Total")
write.csv(costos_grupal_estoc_h,"Costos estocástico mujeres por grupo etario.csv", row.names = FALSE)

```

# Funcion para determinar pension de personas ya pensionadas

```{r}
pension_pen <- function(base_de_datos, sex, t_descuento, m, simulaciones) {
  v <- 1 / (1 + t_descuento)
  # aumento<-(1+0.03)*(1+aumento_real)
  edades <- base_de_datos$Edad
  montos <- base_de_datos$MON_PEN
  fn2 <- function(edad, monto) {
    # print("Hola")
    Edad <- edad
    suma <- 0
    simulacion <- simulaciones
    # monto<-monto*(v*aumento)^(max(jubilacion-Edad,0)) en este caso si se descomenta se calcula para los ya pensionados
    # monto<-monto
    ajuste <- 1
    j <- 1 / m
    i <- 1
    while (simulacion > 0) {
      if (sex) {
        probabilidad <- pxt(ListaDeTablasHombres[[(Edad + 1)]], x = edad, t = 1 / m)
      } else {
        probabilidad <- pxt(ListaDeTablasMujeres[[(Edad + 1)]], x = edad, t = 1 / m)
      }
      vivos <- sum(rbinom(n = simulacion, size = 1, prob = probabilidad))
      simulacion <- vivos
      edad <- edad + 1 / m
      suma <- suma + v^j * ajuste * vivos * 2^(i == 11)
      ajuste <- ajuste * (1 + inflacion)^(i == 12)
      j <- j + 1 / m
      i <- (1 + i) * (i < 12) + 1 * (i == 12)
    }
    return(monto * suma / simulaciones)
  }
  valores <- unlist(future_mapply(FUN = fn2, edad = edades, monto = montos, SIMPLIFY = FALSE))
  return(sum(valores))
}
```

## Calculo de pension estocastico

```{r}
(pension_pen_m <- pension_pen(pen_mujeres, FALSE, 0.07, 12, 1000))
(pension_pen_h <- pension_pen(pen_hombres, TRUE, 0.07, 12, 1000))

fileConn <- file("output.txt")
writeLines(paste("Estocastico:", "Mujeres", pension_pen_m, "Hombres", pension_pen_h, sep = " "), fileConn)
close(fileConn)
```


# Deterministico

# Funciones que nos sirven a ambos

```{r}
x <- c(qxt(MDListaDeTablasHombres[[56 + 1]], x = 56, t = 1), qxt(MDListaDeTablasHombres[[56 + 1]], x = 56, t = 1, decrement = 1))
x
```


```{r}
# porcentaje de pensión
porcentaje_de_pension <- function(antiguedad) {
  porcebtajeVejez <- c((antiguedad >= 5 & antiguedad < 10) * 0.10 +
    (antiguedad >= 10 & antiguedad < 15) * 0.15 +
    (antiguedad >= 15 & antiguedad < 20) * 0.20 +
    (antiguedad >= 20 & antiguedad < 25) * 0.25 +
    (antiguedad >= 25 & antiguedad < 30) * 0.30 +
    (antiguedad >= 30 & antiguedad < 35) * 0.35 +
    (antiguedad >= 35) * 0.4)

  return(porcebtajeVejez)
}


beneficio <- function(antiguedad, decremento, salario, k) {
  antiguedad <- antiguedad + k
  # invalidez
  if (decremento == 1) {
    porcentaje_de_salario <- porcentaje_de_pension(antiguedad) * 0.6
    # vejez
  } else if (decremento == 2) {
    porcentaje_de_salario <- porcentaje_de_pension(antiguedad)
    # muerte
  } else if (decremento == 4) {
    porcentaje_de_salario <- porcentaje_de_pension(antiguedad) * 0.2
  }
  return(salario_referencia(antiguedad, salario, k) * porcentaje_de_salario)
}


RebajoFondosInsuficientes <- function(MontodePension) {
  MontoRebajado <- c(
    MontodePension * 0.10 +
      (MontodePension >= 2293400) * 0.35 * MontodePension +
      (MontodePension >= 2866750) * 0.45 * MontodePension +
      (MontodePension >= 3583437.50) * 0.55 * MontodePension +
      (MontodePension >= 4479296.88) * 0.65 * MontodePension
  )
  if (MontoRebajado > MontodePension * 0.55) {
    return(MontodePension * 0.55)
  }
  return(MontoRebajado)
}
```




## Personas ya pensionadas


```{r}
# hombres
# PensionMensualDeterministico
## No es un seguro de vida completo y necesita diferimiento
PensionMensualDeterministico <-
  function(Edad, hombre, MontoDePension, tasa_descuento) {
    v <- (1) / (1 + tasa_descuento)
    # aguinlado
    MontoAPagar <- MontoDePension
    vectoraguinalado <- c(rep(0, 10), 1, 0)
    vectorMensual <- (seq(1 / 12, (115 - Edad + 1), 1 / 12))
    vectorAnualmensual <- sort(rep(c(0:(115 - Edad)), 12))

    if (hombre) {

      # anualidad inmediata
      anualidad <- pxt(ListaDeTablasHombres[[(Edad + 1)]], x = Edad, t = vectorMensual) *
        (v)^(vectorMensual)
      # monto a pagar con ajuste inflacionario
      MontoAPagar <- MontoAPagar * (1 + 0.04)^(vectorAnualmensual) * 2^(vectoraguinalado)
      suma <- anualidad * MontoAPagar
    } else {
      # anualidad inmediata
      anualidad <- pxt(ListaDeTablasMujeres[[(Edad + 1)]], x = Edad, t = vectorMensual) *
        (v)^(vectorMensual)
      # monto a pagar con ajuste inflacionario
      MontoAPagar <- MontoAPagar * (1 + 0.04)^(vectorAnualmensual) * 2^(vectoraguinalado)
      suma <- anualidad * MontoAPagar
    }
    suma <- sum(suma)
    return(suma)
  }

# calculo de pension para hombres pensionados
MontoDePensionMensualParaHombresDeterministicoPensionados <-
  mapply(
    PensionMensualDeterministico,
    pen_hombres$Edad,
    TRUE,
    pen_hombres$MON_PEN,
    0.07
  )

sum(MontoDePensionMensualParaHombresDeterministicoPensionados)

# calculo de pension para mujeres pensionados
MontoDePensionMensualParaMujeresDeterministicoPensionados <-
  mapply(
    PensionMensualDeterministico,
    pen_mujeres$Edad,
    FALSE,
    pen_mujeres$MON_PEN,
    0.07
  )
sum(MontoDePensionMensualParaMujeresDeterministicoPensionados)
```


```{r}
# calculo de pension para hombres pensionados
MontoDePensionMensualParaHombresDeterministicoPensionados <-
  mapply(
    PensionMensualDeterministico,
    pen_hombres$Edad,
    TRUE,
    pen_hombres$MON_PEN,
    0.07
  )

sum(MontoDePensionMensualParaHombresDeterministicoPensionados)


# calculo de pension para mujeres pensionados
MontoDePensionMensualParaMujeresDeterministicoPensionados <-
  mapply(
    PensionMensualDeterministico,
    pen_mujeres$Edad,
    FALSE,
    pen_mujeres$MON_PEN,
    0.07
  )
sum(MontoDePensionMensualParaMujeresDeterministicoPensionados)
```

## Personal activo
Deterministico para no pensionadas
Funciones a utilizar


### Funcion decremento Invalidez y Vejez

```{r}
# Optimizacion de la funcion
DecrementosIV <- function(Edad, hombre, antiguedad, ultimo_salario, tasa_descuento, tasa_cre_salario, decremento, n = 0) {
  # Se va generar una tabla con los montos definidos para cada edad de pension
  montos_pension <- list()
  v <- (1) / (1 + tasa_descuento)
  edades <- min(Edad):max(Edad)
  
  # La funcion beneficio aun no ha sido definida
  vectoraguinaldo <- c(rep(0, 10), 1, 0)
  for (i in edades) {
    # Tamaño del vector y posiciones, se va pasar como k
    j <- (0:((115 - i) * (n == 0) + n))

    # Vector donde se van guardando los valores sin tener en cuenta el monto de beneficio, esto ya que se le multiplicará a cada individuo
    # PV_aux <- numeric(length(j))
    # Funcion para estimar cada entrada del PV,  que corresponden
    # a cada uno
    funcion_pv <- function(k) {
      PV_aux <- 0
      if (hombre) {
        # Vector al que se eleva el v
=======
DecrementosIV <-
  function(Edad, hombre, antiguedad, ultimo_salario, tasa_descuento, tasa_cre_salario, decremento){
    
    v<-(1)/(1+tasa_descuento)
    
    #La funcion beneficio aun no ha sido definida
    vectoraguinaldo<-c(rep(0,10),1,0)
    PV<-0
    if(hombre){
      for(k in 0:(115-Edad)){
        vectorMensual<-(seq(1/12, (115-Edad+1-k), 1/12))
        vectorAnualmensual<-sort(rep(c(0:(115-Edad-k)),12))
        MontoAPagar <-beneficio(antiguedad, decremento, ultimo_salario, k)*(1+0.04)^(vectorAnualmensual)*2^vectoraguinaldo
        
        
        anualidad <-pxt(ListaDeTablasHombres[[(Edad+1)]],x=Edad+k,t=vectorMensual)*(v)^(vectorMensual)
        suma1 <- sum(anualidad * MontoAPagar)
        PV <- PV + suma1*v^(k+1)*pxt(MDListaDeTablasHombres[[Edad+1]],x=Edad,t=k)*qxt(MDListaDeTablasHombres[[Edad+1]],x=Edad+k ,t=1, decrement=decremento)
        }

    }else{
      
      for(k in 0:(115-Edad)){
        vectorMensual<-(seq(1/12, (115-Edad+1-k), 1/12))
        vectorAnualmensual<-sort(rep(c(0:(115-Edad-k)),12))
        MontoAPagar <-beneficio(antiguedad, decremento, ultimo_salario, k)*(1+0.04)^(vectorAnualmensual)*2^vectoraguinaldo
        
        
        anualidad <-pxt(ListaDeTablasMujeres[[(Edad+1)]],x=Edad+k,t=vectorMensual)*(v)^(vectorMensual)
        suma1 <- sum(anualidad * MontoAPagar)
        
        PV <- PV + suma1*v^(k+1)*pxt(MDListaDeTablasMujeres[[Edad+1]],x=Edad,t=k)*qxt(MDListaDeTablasMujeres[[Edad+1]],x=Edad+k ,t=1, decrement=decremento)
        }
>>>>>>> 6ba3a372075220e4d76191b12e557955a7d0da71

        vectorMensual <- (seq(1 / 12, (115 - i + 1 - k), 1 / 12))

        # Vector para controlar la inflacion
        vectorAnualmensual <- sort(rep(c(0:(115 - i - k)), 12))

        # Vector que contiene los montontos a pagar esto es los montos ajustados por inflacion y multiplicados
        # por si se debería calcular el aguinaldo
        MontoAPagar <- (1 + 0.04)^(vectorAnualmensual) * 2^vectoraguinaldo

        # Vector multiplicando las probabilidad de sobrevivencia es decir tpx*v^t/m
        anualidad <- pxt(ListaDeTablasHombres[[(i + 1)]], x = i + k, t = vectorMensual) * (v)^(vectorMensual)

        # Multiplicando ambos
        suma1 <- sum(anualidad * MontoAPagar)
        PV_aux <- suma1 * v^(k + 1) * pxt(MDListaDeTablasHombres[[i + 1]], x = i, t = k) * qxt(MDListaDeTablasHombres[[i + 1]], x = i + k, t = 1, decrement = decremento)
      } else {
        # Vector al que se eleva el v

        vectorMensual <- (seq(1 / 12, (115 - i + 1 - k), 1 / 12))

        # Vector para controlar la inflacion
        vectorAnualmensual <- sort(rep(c(0:(115 - i - k)), 12))

        # Vector que contiene los montontos a pagar esto es los montos ajustados por inflacion y multiplicados
        # por si se debería calcular el aguinaldo
        MontoAPagar <- (1 + 0.04)^(vectorAnualmensual) * 2^vectoraguinaldo

        # Vector multiplicando las probabilidad de sobrevivencia es decir tpx*v^t/m
        anualidad <- pxt(ListaDeTablasMujeres[[(i + 1)]], x = i + k, t = vectorMensual) * (v)^(vectorMensual)

        # Multiplicando ambos
        suma1 <- sum(anualidad * MontoAPagar)
        PV_aux <- suma1 * v^(k + 1) * pxt(MDListaDeTablasMujeres[[i + 1]], x = i, t = k) * qxt(MDListaDeTablasMujeres[[i + 1]], x = i + k, t = 1, decrement = decremento)
      }
      return(PV_aux)
    }
    montos_pension[[i - min(Edad) + 1]] <- future_sapply(FUN = funcion_pv, X = j)
  }

  # Se procede a programar una funcion la cual permite estimar el valor de los individuos
  costo_individuo <- function(edad, antiguedad, ultimo_salario) {
    # Se carga la lista de acuerdo a la edad
    lista <- montos_pension[[edad - min(Edad) + 1]]
    j <- 0:(115 - edad)
    # Salarios de referencia
    salarios_ref <- unlist(sapply(
      FUN = beneficio, antiguedad = antiguedad,
      decremento = decremento, salario = ultimo_salario, X = j
    ))
    # print(paste(salarios_ref, lista))
    # Se regresa el monto total de los beneficios otorgados
    return(sum(salarios_ref * lista))
  }
  PV <- unlist(future_mapply(FUN = costo_individuo, edad = Edad, antiguedad = antiguedad, ultimo_salario = ultimo_salario))
  return(PV)
}
```

## Funcion decremento muerte

```{r}
# Esta es la funcion de decremento por muerte
DecrementoM <- function(Edad, hombre, antiguedad, ultimo_salario, tasa_descuento, tasa_cre_salario, n = 0) {
  v <- (1) / (1 + tasa_descuento)
  edades <- min(Edad):max(Edad)
  montos_pension <- list()
  # La funcion beneficio aun no ha sido definida
  vectoraguinaldo <- c(rep(0, 10), 1, 0)
  vectorMensual <- seq(1/12, 10, 1 / 12)
  vectorAnualmensual <- sort(rep(c(0:9), 12))
  for (i in edades) {
    if (n != 0) {
      n <- min(((85 - i) * hombre + (77 - i) * !hombre), n)
    }
    j <- (0:(((85 - i) * hombre + (77 - i) * !hombre) * (n == 0) + n))
    if (hombre) {
      function_pv <- function(k) {
        MontoPagar <- (1 + 0.04)^(vectorAnualmensual) * 2^vectoraguinaldo
        suma1 <- sum((v)^(vectorMensual) * MontoPagar)
        PV_aux <- suma1 * v^(k + 1) * pxt(MDListaDeTablasHombres[[i + 1]], x = i, t = k) *
          qxt(MDListaDeTablasHombres[[i + 1]], x = i + k, t = 1, decrement = 4)
        return(PV_aux)
      }
    } else {
      function_pv <- function(k) {
        MontoPagar <- (1 + 0.04)^(vectorAnualmensual) * 2^vectoraguinaldo
        suma1 <- sum((v)^(vectorMensual) * MontoPagar)
        PV_aux <- suma1 * v^(k + 1) * pxt(MDListaDeTablasMujeres[[i + 1]], x = i, t = k) *
          qxt(MDListaDeTablasMujeres[[i + 1]], x = i + k, t = 1, decrement = 4)
        return(PV_aux)
=======
      for (k in 0:(85 - Edad)) {
        MontoAPagar <- beneficio(antiguedad, 4, ultimo_salario, k) * (1 + 0.04)^(vectorAnualmensual) * 2^vectoraguinaldo
        suma1 <- sum((v)^(vectorMensual) * MontoAPagar)
        PV <- PV + suma1 * v^(k + 1) * pxt(MDListaDeTablasHombres[[Edad + 1]], x = Edad, t = k) *
          qxt(MDListaDeTablasHombres[[Edad + 1]], x = Edad + k, t = 1, decrement = 4)
      }
    } else {
      for (k in 0:(77 - Edad)) {
        MontoAPagar <- beneficio(antiguedad, 4, ultimo_salario, k) * (1 + 0.04)^(vectorAnualmensual) * 2^vectoraguinaldo
        suma1 <- sum((v)^(vectorMensual) * MontoAPagar)
        PV <- PV + suma1 * v^(k + 1) * pxt(MDListaDeTablasHombres[[Edad + 1]], x = Edad, t = k) *
          qxt(MDListaDeTablasHombres[[Edad + 1]], x = Edad + k, t = 1, decrement = 4)
>>>>>>> 6ba3a372075220e4d76191b12e557955a7d0da71
      }
    }
    montos_pension[[i - min(Edad) + 1]] <- future_sapply(FUN = function_pv, X = j)
  }
  costo_individuo <- function(edad, antiguedad, ultimo_salario) {
    # Se carga la lista de acuerdo a la edad
    lista <- montos_pension[[edad - min(Edad) + 1]]
    if (n != 0) {
      n <- min(((85 - edad) * hombre + (77 - edad) * !hombre), n)
    }
    j <- (0:(((85 - edad) * hombre + (77 - edad) * !hombre) * (n == 0) + n))
    # Salarios de referencia
    salarios_ref <- unlist(sapply(
      FUN = beneficio, antiguedad = antiguedad,
      decremento = 4, salario = ultimo_salario, X = j
    ))
    # print(paste(salarios_ref, lista))
    # Se regresa el monto total de los beneficios otorgados
    return(sum(salarios_ref * lista))
  }
  PV <- unlist(future_mapply(FUN = costo_individuo, edad = Edad, antiguedad = antiguedad, ultimo_salario = ultimo_salario))
  return(PV)
}

```

## Calculo de personas activas IVM


```{r} 
# Calculo de lo montos para hombres 
edades_h <- afil_hombres$Edad 
antiguedades_h <- afil_hombres$Antiguedad 
salarios_h <- afil_hombres$Salario 
tasa_descuento <- 0.07 
tasa_crecimiento_r <- 0 

# Por invalidez 
salida_invalidez_h <- DecrementosIV(edades_h, TRUE, antiguedades_h, salarios_h, tasa_descuento, tasa_crecimiento_r, 1) 
# Por jubilacion 
salida_jubilacion_h <- DecrementosIV(edades_h, TRUE, antiguedades_h, salarios_h, tasa_descuento, tasa_crecimiento_r, 2)
# Por muerte 
salida_muerte_h <- DecrementoM(edades_h, TRUE, antiguedades_h, salarios_h, tasa_descuento, tasa_crecimiento_r) 

salida_total_hombres <- salida_invalidez_h + salida_jubilacion_h + salida_muerte_h 
 
afil_hombres$Costo_plan <- salida_total_hombres

sum(salida_invalidez_h)
sum(salida_jubilacion_h)
sum(salida_muerte_h)
sum(afil_hombres$Costo_plan)

### Mujeres
edades_m <- afil_mujeres$Edad 
antiguedades_m <- afil_mujeres$Antiguedad 
salarios_m <- afil_mujeres$Salario 
tasa_descuento <- 0.07 
tasa_crecimiento_r <- 0 
# Calculo de lo montos para muejeres 
# Por invalidez 
salida_invalidez_m <- DecrementosIV(edades_m, FALSE, antiguedades_m, salarios_m, 0.07, 0, 1) 
 # Por jubilacion 
salida_jubilacion_m <- DecrementosIV(edades_m, FALSE, antiguedades_m, salarios_m, 0.07, 0, 2) 
 # Por muerte 
salida_muerte_m <- DecrementoM(edades_m, FALSE, antiguedades_m, salarios_m, tasa_descuento, tasa_crecimiento_r) 
 
 
salida_total_mujeres <- salida_invalidez_m + salida_jubilacion_m + salida_muerte_m 
 
afil_mujeres$Costo_plan <- salida_total_mujeres


sum(salida_invalidez_m)
sum(salida_jubilacion_m)
sum(salida_muerte_m)
sum(afil_mujeres$Costo_plan)
```




```{r}
# Ideas para eleboración de la función
# Aqui se programara lo necesario para poder estimar los costos de liquidacion
# Se toma solo aquellas personas que tengan menos de 22 años
# Hay que pagar un 1.5% de los salarios que haya recibido
# Se deberia estimar un pago que se debe hacer dentro de dos años

liquidacion <- function(edad, salario_actual, antiguedad, i, inflacion, aumento_real, porcentaje_aporte, sexo) {
  if (antiguedad + 2 <= 22) {
    v <- 1 / (1 + i)
    # Para estimar el aumento que se le hizo al salario inicial hasta el momento
    aumento <- (1 + inflacion) * (1 + aumento_real)

    # Salario con el que se inició
    salario_inicial <- salario_actual * (aumento)^(-antiguedad) * porcentaje_aporte

    # Salarios que han sido pagados para el momento de la liquidación
    salarios <- salario_inicial * aumento^(0:(antiguedad + 2))
    salarios <- sort(rep(salarios, 12))
    # Se crea un vector con 12 salarios de cada año
    descontado <- v^seq(1 / 12, antiguedad + 3, 1 / 12) * (1 + i)^(antiguedad + 1)

    # Se multiplica el descontado con los salarios pagados
    monto <- sum(salarios * descontado)
    if (sexo == "F") {
      p <- pxt(MDListaDeTablasMujeres[[edad + 1]], x = edad, t = 2)
    } else if (sexo == "M") {
      p <- pxt(MDListaDeTablasHombres[[edad + 1]], x = edad, t = 2)
    }
    return(monto * p)
  } else {
    return(0)
  }
}

attach(afil_hombres)
afil_hombres$Liquidacion <- unlist(future_mapply(
  FUN = liquidacion, edad = Edad,
  salario_actual = Salario, antiguedad = Antiguedad,
  i = interes, inflacion = inflacion, aumento_real,
  porcentaje_aporte = porcentaje_aporte, sexo = "M"
))
attach(afil_mujeres)
afil_mujeres$Liquidacion <- unlist(future_mapply(
  FUN = liquidacion, edad = Edad,
  salario_actual = Salario, antiguedad = Antiguedad,
  i = interes, inflacion = inflacion, aumento_real,
  porcentaje_aporte = porcentaje_aporte, sexo = "F"
))
```








## Cotización futura
```{r}
cotizacionfutura <-
  function(Edad, hombre, antiguedad, ultimo_salario) {
    v <- (1) / (1 + tasa_descuento)

    vectorMensual <- seq(1 / 12, 10, 1 / 12)
#traer al presente 
    if (hombre) {
      ultimo_salario * ((1 + 0.04)*(1+0.025))^(0:(85-Edad))*12*
        pxt(MDListaDeTablasHombres[[(85-Edad)]], x = (85-Edad), t = 1)
      } else {
        ultimo_salario * ((1 + 0.04)*(1+0.025))^(0:(85-Edad))*12*
          pxt(MDListaDeTablasMujeres[[(77 - Edad)]], x = (77 - Edad), t = 1)
      }  
    }
```


```{r}
DecrementosIV <-
  function(Edad, hombre, antiguedad, ultimo_salario, tasa_descuento, tasa_cre_salario, decremento){
    
    
    Edad=afil_hombres$Edad[1]
    hombre=TRUE
    antiguedad=afil_hombres$Antiguedad[1]
    ultimo_salario=afil_hombres$Salario[1]
    tasa_descuento=0.07
    decremento=2
    
    
    datosPersonas<-cbind(Edad,antiguedad,ultimo_salario)
    Edades<-min(Edad):max(Edad)
    v<-(1)/(1+tasa_descuento)
    datosPorEdades<-data.frame()
    
    #La funcion beneficio aun no ha sido definida
    vectoraguinaldo<-c(rep(0,10),1,0)
    PV<-0
    GuardarSuma<-data.frame(matrix(nrow = 116*12, ncol =length(Edades) ))
    if(hombre){
      for (i in 1:length(Edades)) {
        i=1
        for(k in 0:(115-Edades[i])){
          k=1
          vectorMensual<-(seq(1/12, (115-Edades[i]+1-k), 1/12))
          vectorAnualmensual<-sort(rep(c(0:(115-Edades[i]-k)),12))
          
          anualidad <-pxt(ListaDeTablasHombres[[(Edades[i]+1)]],x=Edades[i]+k,t=vectorMensual)*
            (v)^(vectorMensual)
          suma1 <- anualidad * (1+0.04)^(vectorAnualmensual)*2^vectoraguinaldo
          GuardarSuma[k+1]<-c(suma1, rep(0, 116*12-length(suma1)))
        }
        datosPorEdades<-cbind(datosPorEdades, GuardarSuma)
      }

      
      datosPersonas(Edad,antiguedad,ultimo_salario)
      datosPersonas$VP<-1
      for (i in 1:length(datosPersonas$Edad)) {
        for(k in 0:(115-datosPersonas$Edad[i])){
        suma1<-sum(datosPorEdades[k,Edad]* beneficio(datosPersonas$antiguedad[i],decremento,datosPersonas$ultimo_salario[i],k))
        PV <- PV + suma1*v^(k+1)*pxt(MDListaDeTablasHombres[[Edad+1]],x=datosPersonas$Edad[i],t=k)*
          qxt(MDListaDeTablasHombres[[datosPersonas$Edad[i]+1]],x=Edad+k ,t=1, decrement=decremento)
        }
        datosPersonas$VP[i]<-PV
      }


    }
    return(datosPersonas)
  }


```



```{r}

cotizacionfuturaM<-cotizacionfutura(afil_mujeres$Edad, FALSE, afil_mujeres$Antiguedad, afil_mujeres$Salario)
cotizacionfuturaH<-cotizacionfutura(afil_hombres$Edad, FALSE, afil_hombres$Antiguedad, afil_hombres$Salario)


MontoParaMujeresDeterministicoV <-
    DecrementosIV(
    afil_hombres$Edad[1],
    TRUE,
    afil_hombres$Antiguedad[1],
    afil_hombres$Salario[1],
    0.07,
    56,
    2)

```




