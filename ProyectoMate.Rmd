---
title: "Proyecto"
author: "Daniel Sabater"
date: '2022-06-05'
output: html_document
---

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
# Programacion hecha por Joshua Cervantes, Moisés Monge y Daniel Sabater
# Se cargan los paquetes
knitr::opts_chunk$set(echo = FALSE)
options(scipen = 999)
library(lifecontingencies)
library(tidyverse)
library(lubridate)
library(readxl)
library(kableExtra)
library(xtable)
library(stringr)
library(magrittr) # uso de %<>% con funciones de dplyr


# Para paralelizar
library(future.apply)
plan(multicore)

# Se cargan las bases de datos

Afiliados_31_12_2021 <- read_excel("Planilla_Compañia_31_12_2021.xlsx")
Pensionados_31_12_2021 <- read_excel("Compañia_Pensionados_31_12_2021.xlsx", range = "A1:F5006")


# Tablas de decrementos

TablasDecrementosHombres <- read_excel("Tablas de decrementos.xlsx",
  sheet = "Hombres"
)
TablasDecrementosMujeres <- read_excel("Tablas de decrementos.xlsx",
  sheet = "Mujeres"
)


# Tablas de mortalidad dinámicas


TablaDinamica_lxsHombres <- as.data.frame(read_excel("TablaDinamica-lxs.xlsx",
  sheet = "Hombres"
))
TablaDinamica_lxsMujeres <- as.data.frame(read_excel("TablaDinamica-lxs.xlsx",
  sheet = "Mujeres"
))


# Se genera lista con las tablas actuariales de los hombres

ListaDeTablasHombres <- list()
for (j in 1:(length(TablaDinamica_lxsHombres) - 1)) {
  ListaDeTablasHombres[[j]] <- with(
    TablaDinamica_lxsHombres,
    new(
      "actuarialtable",
      interest = 0.06,
      x = TablaDinamica_lxsHombres[, 1],
      lx = TablaDinamica_lxsHombres[, j + 1],
      name = paste("E", (j - 1), sep = "")
    )
  )
}

names(ListaDeTablasHombres) <- paste("E", seq(0, 115), sep = "")

# Se genera lista con las tablas actuariales de las mujeres

ListaDeTablasMujeres <- list()
for (j in 1:(length(TablaDinamica_lxsMujeres) - 1)) {
  ListaDeTablasMujeres[[j]] <- with(
    TablaDinamica_lxsMujeres,
    new(
      "actuarialtable",
      interest = 0.06,
      x = TablaDinamica_lxsMujeres[, 1],
      lx = TablaDinamica_lxsMujeres[, j + 1],
      name = paste("E", (j - 1), sep = "")
    )
  )
}

names(ListaDeTablasMujeres) <- paste("E", seq(0, 115), sep = "")

# Se establece la fecha de la valuación

dia_de_evaluacion <- as.Date("31/12/2021", format = "%d/%m/%Y")

# Afiliados

# Cálculo de edades afiliados

edad <- floor(time_length(difftime(
  dia_de_evaluacion,
  as.Date(as.POSIXct(Afiliados_31_12_2021$Fecha_nacimiento), "UTC")
), "years"))

# Depuración de la columna 'Fecha_ingreso'

Afiliados_31_12_2021 %<>% mutate(Fecha_ingreso = paste(substr(Fecha_ingreso, 1, 4),
  "/", substr(Fecha_ingreso, 5, 6), "/", substr(Fecha_ingreso, 7, 8),
  sep = ""
))

# Depuración de la columna 'Fecha_nacimiento'

Afiliados_31_12_2021 %<>% mutate(Fecha_nacimiento = format(Fecha_nacimiento, "%Y/%m/%d"))

# Cálculo de antigüedad

antiguedad <- floor(time_length(difftime(
  dia_de_evaluacion,
  as.Date(
    Afiliados_31_12_2021$Fecha_ingreso,
    "%Y/%m/%d"
  )
), "years"))

# Inclusión de las variables de edad y antigüedad en la base de datos

Afiliados_31_12_2021 %<>% mutate("Edad" = edad, "Antiguedad" = antiguedad)

# Se calcula edad de los pensionados

Pensionados_31_12_2021 %<>% mutate(FEC_NAC = paste(substr(FEC_NAC, 1, 4),
  "/", substr(FEC_NAC, 5, 6), "/", substr(FEC_NAC, 7, 8),
  sep = ""
))

Pensionados_31_12_2021 %<>% mutate(FEC_RIG_PEN = paste(substr(FEC_RIG_PEN, 1, 4),
  "/", substr(FEC_RIG_PEN, 5, 6), "/", substr(FEC_RIG_PEN, 7, 8),
  sep = ""
))

edad <- floor(time_length(
  difftime(
    dia_de_evaluacion,
    as.Date(
      Pensionados_31_12_2021$FEC_NAC,
      "%Y/%m/%d"
    )
  ),
  "years"
))

tiempo_pension <- floor(time_length(
  difftime(
    dia_de_evaluacion,
    as.Date(
      Pensionados_31_12_2021$FEC_RIG_PEN,
      "%Y/%m/%d"
    )
  ),
  "years"
))

Pensionados_31_12_2021 %<>% mutate("Edad" = edad, "T_Pension" = tiempo_pension)

# se crean bases de datos según genero

afil_hombres <- Afiliados_31_12_2021 %>% filter(Sexo == "M")
pen_hombres <- Pensionados_31_12_2021 %>% filter(SEX == "M")
afil_mujeres <- Afiliados_31_12_2021 %>% filter(Sexo == "F")
pen_mujeres <- Pensionados_31_12_2021 %>% filter(SEX == "F")

# Inflacion
inflacion <- 0.04

# Aumentos real
aumento_real <- 0.0150

# Porcentaje de aporte
porcentaje_aporte <- 0.015

# Interes
interes <- 0.07
```

## Tablas de multiples decrementos


```{r message=FALSE, warning=FALSE}

ProMuerte <- function(q1, q2, q3, q4) {
  a <- q1 * ((-3 * q2 * q3 * q4) / 12 + 4 * (q2 * q3 + q3 * q4 + q4 * q2) / 12 - 6 * (q2 + q3 + q4) / 12 + 1)
  b <- q2 * ((-3 * q1 * q3 * q4) / 12 + 4 * (q1 * q3 + q3 * q4 + q4 * q1) / 12 - 6 * (q1 + q3 + q4) / 12 + 1)
  c <- q3 * ((-3 * q2 * q1 * q4) / 12 + 4 * (q2 * q1 + q1 * q4 + q4 * q2) / 12 - 6 * (q2 + q1 + q4) / 12 + 1)
  d <- q4 * ((-3 * q2 * q3 * q1) / 12 + 4 * (q2 * q3 + q3 * q1 + q1 * q2) / 12 - 6 * (q2 + q3 + q1) / 12 + 1)
  qx <- (a + b + c + d)

  return(data.frame("qx1" = a, "qx2" = b, "qx3" = c, "qx4" = d, "qxC" = qx))
}

# Se genera lista con las tablas de multiples decrementos de los hombres

MDListaDeTablasHombres <- list()
for (m in 1:116) {
  qxs <- ProMuerte(TablasDecrementosHombres$Invalidez, TablasDecrementosHombres$Jubilacion, TablasDecrementosHombres$Retiro, qxt(ListaDeTablasHombres[[m]], 0:115, 1))

  Tabladevida <- as.data.frame(qxs)

  Tabladevida$lx <- (1000000:(1000000 - 115))

  for (i in 1:115) {
    Tabladevida$lx[i + 1] <- Tabladevida$lx[i] - Tabladevida$lx[i] * Tabladevida$qxC[i]
  }

  Tabladevida$d1 <- Tabladevida$lx * Tabladevida$qx1
  Tabladevida$d2 <- Tabladevida$lx * Tabladevida$qx2
  Tabladevida$d3 <- Tabladevida$lx * Tabladevida$qx3
  Tabladevida$d4 <- Tabladevida$lx * Tabladevida$qx4

  Tabladevida$d4[1] + Tabladevida$lx[2]

  MDListaDeTablasHombres[[m]] <-
    new(
      "mdt",
      table = Tabladevida[, 7:10],
      name = paste("E", (m - 1), sep = "")
    )
}

names(MDListaDeTablasHombres) <- paste("E", seq(0, 115), sep = "")



# Se genera lista con las tablas de multiples decrementos de las mujeres

MDListaDeTablasMujeres <- list()
for (m in 1:116) {
  qxs <- ProMuerte(TablasDecrementosMujeres$Invalidez, TablasDecrementosMujeres$Jubilacion, TablasDecrementosMujeres$Retiro, qxt(ListaDeTablasMujeres[[m]], 0, c(1:116)))

  Tabladevida <- as.data.frame(qxs)

  Tabladevida$lx <- (1000000:(1000000 - 115))

  for (i in 1:115) {
    Tabladevida$lx[i + 1] <- Tabladevida$lx[i] - Tabladevida$lx[i] * Tabladevida$qxC[i]
  }

  Tabladevida$d1 <- Tabladevida$lx * Tabladevida$qx1
  Tabladevida$d2 <- Tabladevida$lx * Tabladevida$qx2
  Tabladevida$d3 <- Tabladevida$lx * Tabladevida$qx3
  Tabladevida$d4 <- Tabladevida$lx * Tabladevida$qx4

  Tabladevida$d4[1] + Tabladevida$lx[2]

  MDListaDeTablasMujeres[[m]] <-
    new(
      "mdt",
      table = Tabladevida[, 7:10],
      name = paste("E", (m - 1), sep = "")
    )
}

names(MDListaDeTablasMujeres) <- paste("E", seq(0, 115), sep = "")

rm(qxs)
```




## Escala salarial

```{r}
# Aqui voy a programar la tabla de escala salarial
# se debe hacer por sexo y por edad
# de momentos se calculará el promedio por edad
# Se estima una función lineal entre los dos puntos que faltan
# Pensando si hacerlo por splines
media_mujeres <- aggregate(afil_mujeres$Salario, list(afil_mujeres$Edad), FUN = mean)
media_hombres <- aggregate(afil_hombres$Salario, list(afil_hombres$Edad), FUN = mean)
j <- 2
while (j <= nrow(media_mujeres)) {
  diferencia <- media_mujeres$Group.1[j] - media_mujeres$Group.1[j - 1]
  if (diferencia != 1) {
    m <- (media_mujeres$x[j] - media_mujeres$x[j - 1]) /
      (media_mujeres$Group.1[j] - media_mujeres$Group.1[j - 1])
    b <- media_mujeres$x[j] - m * media_mujeres$Group.1[j]
    edad_faltantes <- media_mujeres$Group.1[j - 1] + (1:(diferencia - 1))
    montos <- m * edad_faltantes + b
    faltantes <- data.frame(Group.1 = edad_faltantes, x = montos)
    media_mujeres <- rbind(media_mujeres[1:j - 1, ], faltantes, media_mujeres[j:nrow(media_mujeres), ])
  }
  j <- j + 1
}
j <- 2
while (j <= nrow(media_hombres)) {
  diferencia <- media_hombres$Group.1[j] - media_hombres$Group.1[j - 1]
  if (diferencia != 1) {
    m <- (media_hombres$x[j] - media_hombres$x[j - 1]) /
      (media_hombres$Group.1[j] - media_hombres$Group.1[j - 1])
    b <- media_hombres$x[j] - m * media_hombres$Group.1[j]
    edad_faltantes <- media_hombres$Group.1[j - 1] + (1:(diferencia - 1))
    montos <- m * edad_faltantes + b
    faltantes <- data.frame(Group.1 = edad_faltantes, x = montos)
    media_hombres <- rbind(media_hombres[1:j - 1, ], faltantes, media_hombres[j:nrow(media_hombres), ])
  }
  j <- j + 1
}
# Mujeres
edad_m <- max(media_mujeres$Group.1)
sal_m <- rep(max(media_mujeres$x), 85 - edad_m)
sal_m <- data.frame(Group.1 = c((edad_m + 1):85, 18), x = c(sal_m, media_mujeres$x[1]))
media_mujeres %<>% rbind(sal_m)

# Hombres
edad_h <- max(media_hombres$Group.1)
sal_h <- rep(max(media_hombres$x), 85 - edad_h)
sal_h <- data.frame(Group.1 = (edad_h + 1):85, x = sal_h)
media_hombres %<>% rbind(sal_h)

# Ordenamiento
media_mujeres <- media_mujeres[order(media_mujeres$Group.1), ]
media_hombres <- media_hombres[order(media_hombres$Group.1), ]

# Unificacion
escala <- data.frame(Edad = 18:85, Hombres = media_hombres$x, Mujeres = media_mujeres$x)
min_m <- escala$Mujeres[1]
min_h <- escala$Hombres[1]
escala %<>% mutate(Hombres = Hombres / min_h, Mujeres = Mujeres / min_m)
write.csv(escala, "./Escala_edad.csv", row.names = FALSE)
```


## Caso por antigüedad 

```{r}
media_mujeres <- aggregate(afil_mujeres$Salario, list(afil_mujeres$Antiguedad), FUN = mean)
media_hombres <- aggregate(afil_hombres$Salario, list(afil_hombres$Antiguedad), FUN = mean)
j <- 2
while (j <= nrow(media_mujeres)) {
  diferencia <- media_mujeres$Group.1[j] - media_mujeres$Group.1[j - 1]
  if (diferencia != 1) {
    m <- (media_mujeres$x[j] - media_mujeres$x[j - 1]) /
      (media_mujeres$Group.1[j] - media_mujeres$Group.1[j - 1])
    b <- media_mujeres$x[j] - m * media_mujeres$Group.1[j]
    edad_faltantes <- media_mujeres$Group.1[j - 1] + (1:(diferencia - 1))
    montos <- m * edad_faltantes + b
    faltantes <- data.frame(Group.1 = edad_faltantes, x = montos)
    media_mujeres <- rbind(media_mujeres[1:j - 1, ], faltantes, media_mujeres[j:nrow(media_mujeres), ])
  }
  j <- j + 1
}
j <- 2
while (j <= nrow(media_hombres)) {
  diferencia <- media_hombres$Group.1[j] - media_hombres$Group.1[j - 1]
  if (diferencia != 1) {
    m <- (media_hombres$x[j] - media_hombres$x[j - 1]) /
      (media_hombres$Group.1[j] - media_hombres$Group.1[j - 1])
    b <- media_hombres$x[j] - m * media_hombres$Group.1[j]
    edad_faltantes <- media_hombres$Group.1[j - 1] + (1:(diferencia - 1))
    montos <- m * edad_faltantes + b
    faltantes <- data.frame(Group.1 = edad_faltantes, x = montos)
    media_hombres <- rbind(media_hombres[1:j - 1, ], faltantes, media_hombres[j:nrow(media_hombres), ])
  }
  j <- j + 1
}

media_mujeres <- rbind(media_mujeres, data.frame(Group.1 = c(45, 46), x = rep(media_mujeres$x[nrow(media_mujeres)])))
escala_antiguedad <- data.frame(Antiguedad = 0:46, Hombres = media_hombres$x, Mujeres = media_mujeres$x)
min_h <- escala_antiguedad$Hombres[1]
min_m <- escala_antiguedad$Mujeres[1]
escala_antiguedad %<>% mutate(Hombres = Hombres / min_h, Mujeres = Mujeres / min_m)
write.csv(escala_antiguedad, "./Escala_antiguedad.csv", row.names = FALSE)
```


# Estadistica

```{r}
# Ejemplo esperanza de vida
Edad <- 30
exn(ListaDeTablasHombres[[Edad + 1]], x = Edad, type = "curtate")
```


# Estocástico


## Personal activo

Primero, se programa una función que calcula el salario de referencia para el cálculo de la pensión para una persona de edad $x$ empleada activa de la compañía dados:

-`antiguedad`: antigüedad a la edad $x$

-`salario`: salario a la edad $x$

-`k`: cantidad de **años** tras los cuáles la persona sufre algún decremento durante la vida laboral, es decir, a la edad $x+k$. Debe cumplir $k\leq 85 -x$ si la persona es hombre o $k\leq 77-x$ si la persona es mujer. 

Esta función se utiliza en el algortimo de Bacinello (1986) para calcular el salario de referencia una vez simulado que ocurre un decremeno en $k$ años.

```{r}
salario_referencia <- function(antiguedad, salario, k) {

  # k es el tiempo hasta que ocurre un decremento o se llega a la edad máxima de jubilación

  t <- max(-antiguedad, k - 4):k

  s <- (length(t) - 1):0

  salario_ref <- mean((1.025)^t * (1.04)^(t + s)) * 12 * salario

  return(salario_ref)
}

salario_referencia_multiple <- function(antiguedad, salario, k) {
  return(sapply(X = k, FUN = salario_referencia, antiguedad = antiguedad, salario = salario))
}
```

Por ejemplo, si una persona de edad $50$ sufre algún decremento $2$ años despúes y tenía a la edad $50$ una antiguedad de $10$ años, entonces el salario de referencia, suponiendo un salario actual de $900,000$ para el cálculo de su pensión es

```{r}
salario_referencia(10, 900000, 2)
```

En segundo lugar, se crea una función que, dado un vector con la distribución de una variable aleatoria discreta $X$ que toma valores en un subconjunto finito de $\mathbb{N}\cup\{0\}$, es decir, un vector de la forma
\[
\bigg( \mathbb{P}(X=0),\mathbb{P}(X\leq 1), \mathbb{P}(X\leq 2),\mathbb{P}(X\leq 3),\dots\bigg),
\]
así como un número $0<p<1$, entonces retorna un valor $k\in\{0,1,2,\dots\}$ tal que

\[
\mathbb{P}(X\leq k-1)<p\leq \mathbb{P}(X\leq k),
\]

que corresponde al $p$-cuantil de $X$. Esta función se utiliza en el algortimo de Bacinello (1986) para hallar el momento de ocurrencia de algún decremento bajo el segundo criterio que plantea dicho método.

```{r}
hallar_cuantil <- function(distribucion, p) {
  hallado <- F

  k <- 0

  q_ant <- 0

  while (hallado == F) {

    # q_nuevo <- 1 - (1-q_ant) * (1-probs[k+1]) # kqx^tau

    q_nuevo <- distribucion[k + 1]

    if (q_ant < p && p <= q_nuevo) {
      hallado <- T
    } else {
      k <- k + 1

      q_ant <- q_nuevo
    }
  }

  return(k)
}
```

```{r}
# Pruebas de la función anterior, favor no borrar aún
# x <- 25
#
# qxs <- ProMuerte(TablasDecrementosMujeres$Invalidez, TablasDecrementosMujeres$Jubilacion, TablasDecrementosMujeres$Retiro, qxt(ListaDeTablasMujeres[[x+1]], 0, c(1:116))) #
#
# dist <- 1-cumprod(1-qxs[,5])
# prob <- runif(1)
#
# plot(0:115, dist) + abline(h = prob, col="red") + abline(v = hallar_cuantil(dist, prob), col="red")
#
# rm(x, dist, prob, qxs)
```

Para calcular los costos asociados a las personas afiliadas al plan ofrecido por la Compañía, se implementa una modificación de uno de los algortimos descritos en Bacinello (1988) bajo un modelo de múltiples decrementos. El mencionado algoritmo permite simular la variable aleatoria $W_{x}$ del tiempo (en años) de trabajo residual de un empleado activo de edad $(x)$. En esencia, el método proporciona un criterio para, en un primer paso y dada una muestra de una distribución $\mathcal{U}(0,1)$, decidir si una persona de edad $(x)$ se llega a jubilar obligatoriamente, en cuyo caso resta solamente simular su tiempo de vida residual. En su defecto, el algoritmo proporciona una regla para asignar, de acuerdo a una segunda muestra de una distribución $\mathcal{U}(0,1)$, cuál de los decrementos restantes sucedió para que no se llegara a la edad máxima de jubilación. Como puede comprobarse, el método requiere a lo sumo dos muestras provenientes de una distribución $\mathcal{U}(0,1)$ en aras de obtener una muestra de $W_{x}$.

Se programa primero la función `costo_afiliado_estocastico`, que retorna una simulación estocástica del costo que representa un afiliado con características:

-`x`: edad actual de la persona. 
-`sexo`: sexo de la persona. Debe estar codificado como "M" o como "F" representando, respectivamente, el sexo masculino o femenino.
-`salario`: salario actual (a la edad $x$)
-`antiguedad`: antigüedad actual de la persona en la Compañía (cantidad de años laborados en la Compañía a la edad $x$)
-`cant_simulaciones`: Cantidad de simulaciones a usar

Asimismo, esta función retorna un valor numérico correspondiente al cálculo del costo para el plan de la Compañía asociado a esta persona de acuerdo al método estocástico.


```{r}

costo_estocastico_grupo_etario <- function(edad, salarios, edad_maxima, antiguedades, cant_simulaciones, lista_tablas_decrementos, lista_tablas_mortalidad) {
  x <- edad
  xi <- edad_maxima
  q4_prima <- lista_tablas_mortalidad[[x + 1]]
  qxs <- cbind(
    qxt(lista_tablas_decrementos[[x + 1]], x = 0:115, t = 1, decrement = 1),
    qxt(lista_tablas_decrementos[[x + 1]], x = 0:115, t = 1, decrement = 2),
    qxt(lista_tablas_decrementos[[x + 1]], x = 0:115, t = 1, decrement = 3),
    qxt(lista_tablas_decrementos[[x + 1]], x = 0:115, t = 1, decrement = 4),
    qxt(lista_tablas_decrementos[[x + 1]], x = 0:115, t = 1)
  )


  # Se define la distribución del modelo de múltiples decrementos (todas las causas)
  FWx <- 1 - cumprod(1 - qxs[, 5])
  # Se toman muestras uniformes en (0,1) según se especificó
  u <- runif(cant_simulaciones)

  # PRIMER CRITERIO
  # Cantidad de casos del primer criterio

  cant_pensiones_edad_maxima <- length(u[u > FWx[xi - x - 1 + (x + 1)]])

  if (cant_pensiones_edad_max == 0) {
    costos_totales_edad_maxima <- 0
  } else {
    # Se simulan los tiempos residuales de vida (en años) para los pensionados de edad máxima (xi)
    tiempos_residuales_edad_maxima <- rLife(n = cant_pensiones_edad_maxima, object = q4_prima, x = xi, k = 1, type = "curtate")
    # Se calculan las anualidades mensuales prepagables según los años de vida restantes y con el periodo de diferimiento xi-x, así como los aguinaldos como una anualidad con el mismo periodo de diferimiento y de tipo inmediata (paga al final del año)
    anualidades_edad_maxima <- future_lapply(X = tiempos_residuales_edad_maxima, FUN = annuity, i = 0.07, m = xi - x, k = 12, type = "due", future.seed = TRUE) %>% unlist()
    aguinaldo_edad_maxima <- future_lapply(X = tiempos_residuales_edad_maxima, FUN = annuity, i = 0.07, m = xi - x, k = 1, type = "immediate", future.seed = TRUE) %>% unlist()
    pagos_edad_maxima <- anualidades_edad_maxima + aguinaldo_edad_maxima


    matriz_salarios_ref_edad_maxima <- mapply(salario_referencia_multiple, antiguedad = antiguedades, salario = salarios, MoreArgs = list(k = xi - x))

    # Se calculan los porcentajes de pensión

    matriz_porcentajes_edad_maxima <- apply(X = outer(antiguedades, rep(xi - x, length(antiguedades)), FUN = "+"), FUN = porcentaje_de_pension, MARGIN = 1)

    # Se calculan los costos por edad_maxima

    # Matriz con costos por escenario: Personas (columnas) y escenarios (filas)

    matriz_costos_edad_maxima <- matriz_porcentajes_edad_maxima * matriz_salarios_ref_edad_maxima * pagos_edad_maxima

    # Costos por persona: suma por columna de la matriz de costos

    costos_edad_maxima_por_persona <- apply(X = matriz_costos_edad_maxima, MARGIN = 2, FUN = sum)

    # Suma de los costos de todas las personas

    costos_totales_edad_maxima <- sum(costos_edad_maxima_por_persona)
  }

  # SEGUNDO CRITERIO: Decremento antes de jubilación

  if (cant_pensiones_edad_max < cant_simulaciones) { # esta condición significa que hay otros escenarios

    # Debe determinarse cuándo ocurrió el decremento y cuál fue
    # Primero se determina cuándo ocurrió, es decir, se buscan los cuantiles de la distribución de Wx que corresponden a las simulaciones U(0,1) restantes
    cuantiles <- future_lapply(X = u[u <= FWx[xi - x - 1 + (x + 1)]], FUN = hallar_cuantil, distribucion = FWx, future.seed = TRUE) %>% unlist()

    # Se calculan las probabilidades condicionales al momento de ocurrencia del decremento
    # Primero, se determinan los numeradores
    numeradores <- qxs[cuantiles + (x + 1), 1:4]
    # Segundo, se determinan los denominadores
    denominadores <- apply(X = numeradores, MARGIN = 1, FUN = sum) %>% unlist()
    denominadores[denominadores == 0] <- 1 # esto se hace para evitar indefiniciones
    # Tercero, se determinan las probabilidades condicionales dividiendo cada fila (numerador) entre el denominador respectivo
    probs_condicionales <- sweep(x = numeradores, MARGIN = 1, STATS = denominadores, FUN = "/")

    # Se determinan los escenarios en que ocurrió cada decremento

    # Primero, se tienen que simular nuevas muestras U(0,1) para los casos que no fueron incluidos en el primer criterio
    u <- runif(cant_simulaciones - cant_pensiones_edad_max)
    # Se determinan los extramemos de los intervalos de decisión
    extremos_intervalos <- future_apply(X = probs_condicionales, MARGIN = 1, FUN = cumsum) %>% t()


    # INVALIDEZ

    # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por invalidez
    posiciones_invalidez <- which(u <= extremos_intervalos[, 1], arr.ind = T)

    if (identical(posiciones_invalidez, integer(0))) {
      costos_totales_invalidez <- 0
    } else {
      # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
      tiempos_hasta_invalidez <- cuantiles[posiciones_invalidez]
      # Se simulan los tiempos residuales de vida
      tiempos_residuales_invalidez <- future_lapply(X = x + tiempos_hasta_invalidez, FUN = rLife, n = 1, object = q4_prima, k = 1, type = "curtate", future.seed = TRUE) %>% unlist()

      # Se calculan las anualidades correspondientes

      anualidades_invalidez <- future_mapply(annuity, i = 0.07, n = tiempos_residuales_invalidez, m = tiempos_hasta_invalidez, k = 12, type = "due", SIMPLIFY = "vector", future.seed = TRUE)

      aguinaldos_invalidez <- future_mapply(annuity, i = 0.07, n = tiempos_residuales_invalidez, m = tiempos_hasta_invalidez, k = 1, type = "immediate", SIMPLIFY = "vector", future.seed = TRUE)

      pagos_invalidez <- anualidades_invalidez + aguinaldos_invalidez

      # Se calculan los salarios de referencia en este caso

      matriz_salarios_ref_invalidez <- mapply(salario_referencia_multiple, antiguedad = antiguedades, salario = salarios, MoreArgs = list(k = tiempos_hasta_invalidez))

      # Se calculan los porcentajes de pensión

      matriz_porcentajes_invalidez <- apply(X = outer(antiguedades, tiempos_hasta_invalidez, FUN = "+"), FUN = porcentaje_de_pension, MARGIN = 1)

      # Se calculan los costos por invalidez

      # Matriz con costos por escenario: Personas (columnas) y escenarios (filas)

      matriz_costos_invalidez <- 0.6 * matriz_porcentajes_invalidez * matriz_salarios_ref_invalidez * pagos_invalidez

      # Costos por persona: suma por columna de la matriz de costos

      costos_invalidez_por_persona <- apply(X = matriz_costos_invalidez, MARGIN = 2, FUN = sum)

      # Suma de los costos de todas las personas

      costos_totales_invalidez <- sum(costos_invalidez_por_persona)
    }
    # JUBILACIÓN

    # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por jubilación

    posiciones_jubilacion <- which(extremos_intervalos[, 1] < u && u <= extremos_intervalos[, 2], arr.ind = T)


    if (identical(posiciones_jubilacion, integer(0))) {
      costos_totales_jubilacion <- 0
    } else {
      # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
      tiempos_hasta_jubilacion <- cuantiles[posiciones_jubilacion]

      # Se simulan los tiempos residuales de vida
      tiempos_residuales_jubilacion <- future_lapply(X = x + tiempos_hasta_jubilacion, FUN = rLife, n = 1, object = q4_prima, k = 1, type = "curtate", future.seed = TRUE) %>% unlist()

      # Se calculan las anualidades correspondientes, incluyendo el aguinaldo
      anualidades_jubilacion <- future_mapply(annuity, i = 0.07, n = tiempos_residuales_jubilacion, m = tiempos_hasta_jubilacion, k = 12, type = "due", SIMPLIFY = "vector", future.seed = TRUE)
      aguinaldos_jubilacion <- future_mapply(annuity, i = 0.07, n = tiempos_residuales_jubilacion, m = tiempos_hasta_jubilacion, k = 1, type = "immediate", SIMPLIFY = "vector", future.seed = TRUE)
      pagos_jubilacion <- anualidades_jubilacion + aguinaldos_jubilacion

      # Se calculan los salarios de referencia en este caso

      matriz_salarios_ref_jubilacion <- mapply(salario_referencia_multiple, antiguedad = antiguedades, salario = salarios, MoreArgs = list(k = tiempos_hasta_jubilacion))

      # Se calculan los porcentajes de pensión

      matriz_porcentajes_jubilacion <- apply(X = outer(antiguedades, tiempos_hasta_jubilacion, FUN = "+"), FUN = porcentaje_de_pension, MARGIN = 1)

      # Se calculan los costos por jubilacion

      # Matriz con costos por escenario: Personas (columnas) y escenarios (filas)

      matriz_costos_jubilacion <- matriz_porcentajes_jubilacion * matriz_salarios_ref_jubilacion * pagos_jubilacion

      # Costos por persona: suma por columna de la matriz de costos

      costos_jubilacion_por_persona <- apply(X = matriz_costos_jubilacion, MARGIN = 2, FUN = sum)

      # Suma de los costos de todas las personas

      costos_totales_jubilacion <- sum(costos_jubilacion_por_persona)
    }

    # RETIRO

    # No es necesario calcular nada ya que no les otorga pensión

    # MUERTE

    # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por muerte

    posiciones_muerte <- which(extremos_intervalos[, 3] < u, arr.ind = T)


    if (identical(posiciones_muerte, integer(0))) {
      costos_totales_muerte <- 0
    } else {
      # Se guarda la cantidad de años tras los cuáles ocurrió el decremento

      tiempos_hasta_muerte <- cuantiles[posiciones_muerte]

      # Se calculan las anualidades a 10 años correspondientes incluyendo el aguinaldo
      anualidades_muerte <- future_mapply(annuity, i = 0.07, n = 10, m = tiempos_hasta_muerte, k = 12, type = "due", SIMPLIFY = "vector", future.seed = TRUE)
      aguinaldos_muerte <- future_mapply(annuity, i = 0.07, n = 10, m = tiempos_hasta_muerte, k = 1, type = "immediate", SIMPLIFY = "vector", future.seed = TRUE)
      pagos_muerte <- anualidades_muerte + aguinaldos_muerte

      # Se calculan los salarios de referencia en este caso

      matriz_salarios_ref_muerte <- mapply(salario_referencia_multiple, antiguedad = antiguedades, salario = salarios, MoreArgs = list(k = tiempos_hasta_muerte))

      # Se calculan los porcentajes de pensión

      matriz_porcentajes_muerte <- apply(X = outer(antiguedades, tiempos_hasta_muerte, FUN = "+"), FUN = porcentaje_de_pension, MARGIN = 1)

      # Se calculan los costos por muerte

      # Matriz con costos por escenario: Personas (columnas) y escenarios (filas)

      matriz_costos_muerte <- matriz_porcentajes_muerte * matriz_salarios_ref_muerte * pagos_muerte

      # Costos por persona: suma por columna de la matriz de costos

      costos_muerte_por_persona <- apply(X = matriz_costos_muerte, MARGIN = 2, FUN = sum)

      # Suma de los costos de todas las personas

      costos_totales_muerte <- sum(costos_muerte_por_persona)
    }
  }
  # RETORNAR LOS COSTOS TOTALES

  return(sum(costos_totales_edad_maxima, costos_totales_invalidez, costos_totales_jubilacion, costos_totales_muerte) / cant_simulaciones)
}
```

```{r}

costo_afiliado_estocastico <- function(x, sexo, salario, antiguedad, cant_simulaciones) {
  if (sexo == "M") {
    # Edad máxima de jubilacion
    xi <- 85
    # Tabla de probabilidades de muerte simples
    q4_prima <- ListaDeTablasHombres[[x + 1]]
    # Vector con probabilidades (q1, q2, q3, q4, q_Tau)
    qxs <- ProMuerte(TablasDecrementosHombres$Invalidez, TablasDecrementosHombres$Jubilacion, TablasDecrementosHombres$Retiro, qxt(ListaDeTablasHombres[[x + 1]], 0, c(1:116)))
  } else {
    # Edad máxima de jubilacion
    xi <- 77
    # Vector de probabilidades de muerte simples
    q4_prima <- ListaDeTablasMujeres[[x + 1]]
    # Vector con probabilidades (q1, q2, q3, q4, q_Tau)
    qxs <- ProMuerte(TablasDecrementosMujeres$Invalidez, TablasDecrementosMujeres$Jubilacion, TablasDecrementosMujeres$Retiro, qxt(ListaDeTablasMujeres[[x + 1]], 0, c(1:116)))
  }

  # Se define la distribución del modelo de múltiples decrementos (todas las causas)
  FWx <- 1 - cumprod(1 - qxs[, 5])
  # Se toman muestras uniformes en (0,1) según se especificó
  u <- runif(cant_simulaciones)

  # PRIMER CRITERIO: Jubilación obligatoria
  # Se cuenta la cantidad escenarios en que ocurrió esta condición: Se comprueba u>FWx(xi-x-1)
  cant_pensiones_edad_max <- length(u[u > FWx[xi - x - 1 + (x + 1)]])

  salario_ref_primer_criterio <- 0

  if (identical(cant_pensiones_edad_max, numeric(0))) {
    pagos_primer_criterio <- 0
  } else {
    # Se calcula el salario de referencia en este caso
    salario_ref_primer_criterio <- salario_referencia(antiguedad, salario, xi - x)
    # Se simulan los tiempos residuales de vida (en años) para los pensionados de edad máxima (xi)
    tiempos_residuales_edad_max <- rLife(n = cant_pensiones_edad_max, object = q4_prima, x = xi, k = 1, type = "curtate")
    # Se calculan las anualidades mensuales prepagables según los años de vida restantes y con el periodo de diferimiento xi-x, así como los aguinaldos como una anualidad con el mismo periodo de diferimiento y de tipo inmediata (paga al final del año)
    anualidades_primer_criterio <- future_lapply(X = tiempos_residuales_edad_max, FUN = annuity, i = 0.07, m = xi - x, k = 12, type = "due", future.seed = TRUE) %>% unlist()
    aguinaldo_primer_criterio <- future_lapply(X = tiempos_residuales_edad_max, FUN = annuity, i = 0.07, m = xi - x, k = 1, type = "immediate", future.seed = TRUE) %>% unlist()
    pagos_primer_criterio <- anualidades_primer_criterio + aguinaldo_primer_criterio
  }
  # Se calculan los costos asociados al primer criterio del algoritmo
  costos_edad_max <- salario_ref * pagos_primer_criterio

  # SEGUNDO CRITERIO: Decremento antes de jubilación

  if (cant_pensiones_edad_max < cant_simulaciones) { # esta condición significa que hay otros escenarios

    # Debe determinarse cuándo ocurrió el decremento y cuál fue
    # Primero se determina cuándo ocurrió, es decir, se buscan los cuantiles de la distribución de Wx que corresponden a las simulaciones U(0,1) restantes
    cuantiles <- future_lapply(X = u[u <= FWx[xi - x - 1 + (x + 1)]], FUN = hallar_cuantil, distribucion = FWx, future.seed = TRUE) %>% unlist()

    # Se calculan las probabilidades condicionales al momento de ocurrencia del decremento
    # Primero, se determinan los numeradores
    numeradores <- qxs[cuantiles + (x + 1), 1:4]
    # Segundo, se determinan los denominadores
    denominadores <- future_apply(X = numeradores, MARGIN = 1, FUN = sum) %>% unlist()
    # Tercero, se determinan las probabilidades condicionales dividiendo cada fila (numerador) entre el denominador respectivo

    probs_condicionales <- sweep(x = numeradores, MARGIN = 1, STATS = denominadores, FUN = "/")

    # Se determinan los escenarios en que ocurrió cada decremento

    # Primero, se tienen que simular nuevas muestras U(0,1) para los casos que no fueron incluidos en el primer criterio
    u <- runif(cant_simulaciones - cant_pensiones_edad_max)
    # Se determinan los extramemos de los intervalos de decisión
    extremos_intervalos <- future_apply(X = probs_condicionales, MARGIN = 1, FUN = cumsum) %>% t()

    # INVALIDEZ

    # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por invalidez
    posiciones_invalidez <- which(u <= extremos_intervalos[, 1], arr.ind = T)
    # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
    tiempos_hasta_invalidez <- cuantiles[posiciones_invalidez]
    if (identical(tiempos_hasta_invalidez, numeric(0))) {
      tiempos_hasta_invalidez <- 0
      tiempos_residuales_invalidez <- 0
    } else {
      # Se simulan los tiempos residuales de vida
      tiempos_residuales_invalidez <- future_lapply(X = x + tiempos_hasta_invalidez, FUN = rLife, n = 1, object = q4_prima, k = 1, type = "curtate", future.seed = TRUE) %>% unlist()
    }
    # Se calculan las anualidades correspondientes
    anualidades_invalidez <- future_mapply(annuity, i = 0.07, n = tiempos_residuales_invalidez, m = tiempos_hasta_invalidez, k = 12, type = "due", SIMPLIFY = "vector", future.seed = TRUE)
    aguinaldos_invalidez <- future_mapply(annuity, i = 0.07, n = tiempos_residuales_invalidez, m = tiempos_hasta_invalidez, k = 1, type = "immediate", SIMPLIFY = "vector", future.seed = TRUE)
    pagos_invalidez <- anualidades_invalidez + aguinaldos_invalidez

    # Se calculan los salarios de referencia en este caso
    salarios_ref_invalidez <- future_lapply(X = tiempos_hasta_invalidez, FUN = salario_referencia, antiguedad = antiguedad, salario = salario, future.seed = TRUE) %>% unlist()
    # Se calculan los porcentajes de pensión
    porcentajes_invalidez <- future_lapply(X = antiguedad + tiempos_hasta_invalidez, FUN = porcentaje_de_pension, future.seed = TRUE) %>% unlist()
    # Se calculan los costos por invalidez
    costos_invalidez <- 0.6 * porcentajes_invalidez * salarios_ref_invalidez * pagos_invalidez

    # JUBILACIÓN

    # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por jubilación

    posiciones_jubilacion <- which(extremos_intervalos[, 1] < u && u <= extremos_intervalos[, 2], arr.ind = T)

    # Se guarda la cantidad de años tras los cuáles ocurrió el decremento
    tiempos_hasta_jubilacion <- cuantiles[posiciones_jubilacion]

    if (identical(tiempos_hasta_jubilacion, numeric(0))) {
      tiempos_hasta_jubilacion <- 0
      tiempos_residuales_jubilacion <- 0
    } else {
      # Se simulan los tiempos residuales de vida
      tiempos_residuales_jubilacion <- future_lapply(X = x + tiempos_hasta_jubilacion, FUN = rLife, n = 1, object = q4_prima, k = 1, type = "curtate", future.seed = TRUE) %>% unlist()
    }
    # Se calculan las anualidades correspondientes
    anualidades_jubilacion <- future_mapply(annuity, i = 0.07, n = tiempos_residuales_jubilacion, m = tiempos_hasta_jubilacion, k = 12, type = "due", SIMPLIFY = "vector", future.seed = TRUE)
    aguinaldos_jubilacion <- future_mapply(annuity, i = 0.07, n = tiempos_residuales_jubilacion, m = tiempos_hasta_jubilacion, k = 1, type = "immediate", SIMPLIFY = "vector", future.seed = TRUE)
    pagos_jubilacion <- anualidades_jubilacion + aguinaldos_jubilacion
    # Se calculan los salarios de referencia en este caso
    salarios_ref_jubilacion <- future_lapply(X = tiempos_hasta_jubilacion, FUN = salario_referencia, antiguedad = antiguedad, salario = salario, future.seed = TRUE) %>% unlist()
    # Se calculan los porcentajes de pensión
    porcentajes_jubilacion <- future_lapply(X = antiguedad + tiempos_hasta_jubilacion, FUN = porcentaje_de_pension, future.seed = TRUE) %>% unlist()
    # Se calculan los costos por jubilacion
    costos_jubilacion <- porcentajes_jubilacion * salarios_ref_jubilacion * pagos_jubilacion

    # RETIRO

    # No es necesario calcular nada ya que no les otorga pensión

    # MUERTE

    # Se determinan las posiciones del vector de muestras uniformes para el segundo esenario en que el decremento se dio por muerte

    posiciones_muerte <- which(extremos_intervalos[, 3] < u, arr.ind = T)


    # Se guarda la cantidad de años tras los cuáles ocurrió el decremento

    tiempos_hasta_muerte <- cuantiles[posiciones_muerte]


    if (identical(tiempos_hasta_muerte, numeric(0))) {
      tiempos_hasta_muerte <- 0
    }


    # Se calculan las anualidades a 10 años correspondientes
    anualidades_muerte <- future_mapply(annuity, i = 0.07, n = 10, m = tiempos_hasta_muerte, k = 12, type = "due", SIMPLIFY = "vector", future.seed = TRUE)
    aguinaldos_muerte <- future_mapply(annuity, i = 0.07, n = 10, m = tiempos_hasta_muerte, k = 1, type = "immediate", SIMPLIFY = "vector", future.seed = TRUE)
    pagos_muerte <- anualidades_muerte + aguinaldos_muerte

    # Se calculan los salarios de referencia en este caso
    salarios_ref_muerte <- future_lapply(X = tiempos_hasta_muerte, FUN = salario_referencia, antiguedad = antiguedad, salario = salario, future.seed = TRUE) %>% unlist()
    # Se calculan los porcentajes de pensión
    porcentajes_muerte <- future_lapply(X = antiguedad + tiempos_hasta_muerte, FUN = porcentaje_de_pension, future.seed = TRUE) %>% unlist()
    # Se calculan los costos por muerte
    costos_muerte <- 0.2 * porcentajes_muerte * salarios_ref_muerte * anualidades_muerte
  }
  costo_estocastico <- sum(costos_edad_max, costos_invalidez, costos_jubilacion, costos_muerte) / cant_simulaciones

  return(costo_estocastico)
}
```



A continuación se presenta un ejemplo de la funcionalidad del mismo para una mujer de 55 años, empleada activa de la Compañía, con un salario de referencia de 1,000,000.00 y una antigüedad de 5 años:

```{r}
# i <- 1
# costos <- rep(0, 10622)
# t <- proc.time()
# for (i in 1:1000){
# edad <- Afiliados_31_12_2021$Edad[i]
# salario <- Afiliados_31_12_2021$Salario[i]
# sexo <- Afiliados_31_12_2021$Sexo[i]
# antiguedad <- Afiliados_31_12_2021$Antiguedad[i]
# cant_simulaciones <- 1000
# costos[i] <- costo_afiliado_estocastico(edad, sexo, salario, antiguedad, cant_simulaciones)
# }
# proc.time()-t


t <- proc.time()
costos <- future_mapply(
  FUN = costo_afiliado_estocastico,
  x = Afiliados_31_12_2021$Edad[1:100],
  sexo = Afiliados_31_12_2021$Sexo[1:100],
  salario = Afiliados_31_12_2021$Salario[1:100],
  antiguedad = Afiliados_31_12_2021$Antiguedad[1:100],
  cant_simulaciones = 10000,
  SIMPLIFY = "vector", future.seed = TRUE
)
proc.time() - t

# write.csv(costos,file="resultados_estocástico_afiliados.csv",row.names=F)
# costos2 <- read.csv("resultados_estocástico_afiliados.csv")
```



# Funcion para determinar pension de personas ya pensionadas

```{r}
pension_pen <- function(base_de_datos, sex, t_descuento, m, simulaciones) {
  v <- 1 / (1 + t_descuento)
  # aumento<-(1+0.03)*(1+aumento_real)
  edades <- base_de_datos$Edad
  montos <- base_de_datos$MON_PEN
  fn2 <- function(edad, monto) {
    # print("Hola")
    Edad <- edad
    suma <- 0
    simulacion <- simulaciones
    # monto<-monto*(v*aumento)^(max(jubilacion-Edad,0)) en este caso si se descomenta se calcula para los ya pensionados
    # monto<-monto
    ajuste <- 1
    j <- 1 / m
    i <- 1
    while (simulacion > 0) {
      if (sex) {
        probabilidad <- pxt(ListaDeTablasHombres[[(Edad + 1)]], x = edad, t = 1 / m)
      } else {
        probabilidad <- pxt(ListaDeTablasMujeres[[(Edad + 1)]], x = edad, t = 1 / m)
      }
      vivos <- sum(rbinom(n = simulacion, size = 1, prob = probabilidad))
      simulacion <- vivos
      edad <- edad + 1 / m
      suma <- suma + v^j * ajuste * vivos * 2^(i == 11)
      ajuste <- ajuste * (1 + inflacion)^(i == 12)
      j <- j + 1 / m
      i <- (1 + i) * (i < 12) + 1 * (i == 12)
    }
    return(monto * suma / simulaciones)
  }
  valores <- unlist(future_mapply(FUN = fn2, edad = edades, monto = montos, SIMPLIFY = FALSE))
  return(sum(valores))
}
```

## Calculo de pension estocastico

```{r}
(pension_pen_m <- pension_pen(pen_mujeres, FALSE, 0.07, 12, 1000))
(pension_pen_h <- pension_pen(pen_hombres, TRUE, 0.07, 12, 1000))

fileConn <- file("output.txt")
writeLines(paste("Estocastico:", "Mujeres", pension_pen_m, "Hombres", pension_pen_h, sep = " "), fileConn)
close(fileConn)
```


# Deterministico

# Funciones que nos sirven a ambos

```{r}
x <- c(qxt(MDListaDeTablasHombres[[56 + 1]], x = 56, t = 1), qxt(MDListaDeTablasHombres[[56 + 1]], x = 56, t = 1, decrement = 1))
x
```


```{r}
# porcentaje de pensión
porcentaje_de_pension <- function(antiguedad) {
  porcebtajeVejez <- c((antiguedad >= 5 & antiguedad < 10) * 0.10 +
    (antiguedad >= 10 & antiguedad < 15) * 0.15 +
    (antiguedad >= 15 & antiguedad < 20) * 0.20 +
    (antiguedad >= 20 & antiguedad < 25) * 0.25 +
    (antiguedad >= 25 & antiguedad < 30) * 0.30 +
    (antiguedad >= 30 & antiguedad < 35) * 0.35 +
    (antiguedad >= 35) * 0.4)

  return(porcebtajeVejez)
}


RebajoFondosInsuficientes <- function(MontodePension) {
  MontoRebajado <- c(
    MontodePension * 0.10 +
      (MontodePension >= 2293400) * 0.35 * MontodePension +
      (MontodePension >= 2866750) * 0.45 * MontodePension +
      (MontodePension >= 3583437.50) * 0.55 * MontodePension +
      (MontodePension >= 4479296.88) * 0.65 * MontodePension
  )
  if (MontoRebajado > MontodePension * 0.55) {
    return(MontodePension * 0.55)
  }
  return(MontoRebajado)
}
```

## Personal activo

```{r}

```


## Personas ya pensionadas
```{r}
# PensionMensualDeterministico
PensionMensualDeterministico <-
  function(Edad, hombre, MontoDePension, tasa_descuento) {

    # Preguntar si lo dividimos entre 12
    v <- (1) / (1 + tasa_descuento)
    # aguinlado
    MontoAPagar <- MontoDePension * (1 + 1 / 12)
    if (hombre) {

      # anualidad inmediata
      vectorMensual <- (seq(1 / 12, (115 - Edad + 1), 1 / 12))
      vectorAnualmensual <- sort(rep(c(0:(115 - Edad)), 12))
      anualidad <- pxt(ListaDeTablasHombres[[(Edad + 1)]], x = Edad, t = vectorMensual) *
        (v)^(vectorMensual)
      # monto a pagar con ajuste inflacionario
      MontoAPagar <- MontoAPagar * (1 + 0.04)^(vectorAnualmensual)
      suma <- anualidad * MontoAPagar
    } else {


      # anualidad inmediata
      vectorMensual <- (seq(1 / 12, (115 - Edad + 1), 1 / 12))
      vectorAnualmensual <- sort(rep(c(0:(115 - Edad)), 12))
      anualidad <- pxt(ListaDeTablasMujeres[[(Edad + 1)]], x = Edad, t = vectorMensual) *
        (v)^(vectorMensual)
      # monto a pagar con ajuste inflacionario
      MontoAPagar <- MontoAPagar * (1 + 0.04)^(vectorAnualmensual)
      suma <- anualidad * MontoAPagar
    }
    suma <- sum(suma)
    return(suma)
  }
```


```{r}
# hombres
# PensionMensualDeterministico
## No es un seguro de vida completo y necesita diferimiento
PensionMensualDeterministico <-
  function(Edad, hombre, MontoDePension, tasa_descuento) {
    v <- (1) / (1 + tasa_descuento)
    # aguinlado
    MontoAPagar <- MontoDePension
    vectoraguinalado <- c(rep(0, 10), 1, 0)
    vectorMensual <- (seq(1 / 12, (115 - Edad + 1), 1 / 12))
    vectorAnualmensual <- sort(rep(c(0:(115 - Edad)), 12))

    if (hombre) {

      # anualidad inmediata
      anualidad <- pxt(ListaDeTablasHombres[[(Edad + 1)]], x = Edad, t = vectorMensual) *
        (v)^(vectorMensual)
      # monto a pagar con ajuste inflacionario
      MontoAPagar <- MontoAPagar * (1 + 0.04)^(vectorAnualmensual) * 2^(vectoraguinalado)
      suma <- anualidad * MontoAPagar
    } else {
      # anualidad inmediata
      anualidad <- pxt(ListaDeTablasMujeres[[(Edad + 1)]], x = Edad, t = vectorMensual) *
        (v)^(vectorMensual)
      # monto a pagar con ajuste inflacionario
      MontoAPagar <- MontoAPagar * (1 + 0.04)^(vectorAnualmensual) * 2^(vectoraguinalado)
      suma <- anualidad * MontoAPagar
    }
    suma <- sum(suma)
    return(suma)
  }

# calculo de pension para hombres pensionados
MontoDePensionMensualParaHombresDeterministicoPensionados <-
  mapply(
    PensionMensualDeterministico,
    pen_hombres$Edad,
    TRUE,
    pen_hombres$MON_PEN,
    0.07
  )

sum(MontoDePensionMensualParaHombresDeterministicoPensionados)

# calculo de pension para mujeres pensionados
MontoDePensionMensualParaMujeresDeterministicoPensionados <-
  mapply(
    PensionMensualDeterministico,
    pen_mujeres$Edad,
    FALSE,
    pen_mujeres$MON_PEN,
    0.07
  )
sum(MontoDePensionMensualParaMujeresDeterministicoPensionados)
```


```{r}
# calculo de pension para hombres pensionados
MontoDePensionMensualParaHombresDeterministicoPensionados <-
  mapply(
    PensionMensualDeterministico,
    pen_hombres$Edad,
    TRUE,
    pen_hombres$MON_PEN,
    0.07
  )

sum(MontoDePensionMensualParaHombresDeterministicoPensionados)


# calculo de pension para mujeres pensionados
MontoDePensionMensualParaMujeresDeterministicoPensionados <-
  mapply(
    PensionMensualDeterministico,
    pen_mujeres$Edad,
    FALSE,
    pen_mujeres$MON_PEN,
    0.07
  )
sum(MontoDePensionMensualParaMujeresDeterministicoPensionados)
```


Deterministico para no pensionadas
Funciones a utilizar

Funcion promedio, la cual calcula el promedio de los ultimos 60 salarios, base para obtener el vector de beneficios
```{r}
promedio <- function(k, antiguedad, salario) {
  s <- k * 12
  if (s >= 60) {
    initialyear <- (s - 60) / 12
    montoinicial <- salario * fs^initialyear
    montoactualizado <- montoinicial * fishermensual[1:60]
    promedio <- (montoactualizado * inflacionmensual[60:1]) / 60
  } else {
    g <- min(60 - s, antiguedad)
    montoproyectado <- salario * fishermensual[1:s]
    promedioproyectado <- (montoproyectado * inflacionmensual[s:1])
    montopasado <- salario * negfishermensual[1:g]
    promediopasado <- (montopasado * inflacionmensual[(s + g):s])
  }
}
```



```{r}
DecrementoVejez <-
  function(Edad, hombre, antiguedad, ultimo_salario, tasa_descuento, tasa_cre_salario) {

    # Considerando una inflacion del 3%
    tasa_cre_salario <- (1 + tasa_cre_salario) * (1 + 0.03)
    v <- (1) / (1 + tasa_descuento)

    # La funcion beneficio aun no ha sido definida

    vectorMensual <- (seq(1 / 12, (115 - Edad + 1), 1 / 12))
    vectorAnualmensual <- sort(rep(c(0:(115 - Edad)), 12))
    MontoAPagar <- SalarioPromedio * porcentaje_de_pension(antiguedad) * (1 + 0.03)^(vectorAnualmensual)


    if (hombre) {
      for (k in 1:(115 - Edad)) {
        vectorMensual <- (seq(1 / 12, (115 - Edad + 1), 1 / 12))
        vectorAnualmensual <- sort(rep(c(0:(115 - Edad)), 12))
        anualidad <- pxt(ListaDeTablasHombres[[(Edad + 1)]], x = Edad + k, t = vectorMensual) * (v)^(vectorMensual) * Beneficio(x, k)
        suma1 <- sum(anualidad * MontoAPagar)

        PV <- suma1 * v^k * pxt(MDListaDeTablasHombres[[Edad + 1]], x = edad, t = k) * qxt(MDListaDeTablasHombres[[Edad + 1]], x = edad, t = k, decrement = 1)
      }

      MontoAPagar <- MontoAPagar * (1 + 0.03)^(vectorAnualmensual)
      suma <- anualidad * MontoAPagar
    } else {
      for (k in 1:(115 - Edad)) {
        vectorMensual <- (seq(1 / 12, (115 - Edad + 1), 1 / 12))
        vectorAnualmensual <- sort(rep(c(0:(115 - Edad)), 12))
        anualidad <- pxt(ListaDeTablasMujeres[[(Edad + 1)]], x = Edad + k, t = vectorMensual) * (v)^(vectorMensual)
        suma1 <- sum(anualidad * MontoAPagar)

        PV <- suma1 * v^k * pxt(MDListaDeTablasMujeres[[Edad + 1]], x = edad, t = k) * qxt(MDListaDeTablasMujeres[[Edad + 1]], x = edad, t = k, decrement = 1)
      }

      MontoAPagar <- MontoAPagar * (1 + 0.03)^(vectorAnualmensual)
      suma <- anualidad * MontoAPagar
    }
  }
```

```{r}

DecrementoInvalidez <-
  function(Edad, hombre, antiguedad, ultimo_salario, tasa_descuento, tasa_cre_salario) {

    # Considerando una inflacion del 3%
    tasa_cre_salario <- (1 + tasa_cre_salario) * (1 + 0.03)
    v <- (1) / (1 + tasa_descuento)

    # La funcion beneficio aun no ha sido definida

    vectorMensual <- (seq(1 / 12, (115 - Edad + 1), 1 / 12))
    vectorAnualmensual <- sort(rep(c(0:(115 - Edad)), 12))
    MontoAPagar <- SalarioPromedio * porcentaje_de_pension(antiguedad) * (1 + 0.03)^(vectorAnualmensual)


    if (hombre) {
      for (k in 1:(115 - Edad)) {
        vectorMensual <- (seq(1 / 12, (115 - Edad + 1), 1 / 12))
        vectorAnualmensual <- sort(rep(c(0:(115 - Edad)), 12))
        anualidad <- pxt(ListaDeTablasHombres[[(Edad + 1)]], x = Edad + k, t = vectorMensual) * (v)^(vectorMensual) * Beneficio(x, k)
        suma1 <- sum(anualidad * MontoAPagar)

        PV <- suma1 * v^k * pxt(MDListaDeTablasHombres[[Edad + 1]], x = edad, t = k) * qxt(MDListaDeTablasHombres[[Edad + 1]], x = edad, t = k, decrement = 2)
      }

      MontoAPagar <- MontoAPagar * (1 + 0.03)^(vectorAnualmensual)
      suma <- anualidad * MontoAPagar
    } else {
      for (k in 1:(115 - Edad)) {
        vectorMensual <- (seq(1 / 12, (115 - Edad + 1), 1 / 12))
        vectorAnualmensual <- sort(rep(c(0:(115 - Edad)), 12))
        anualidad <- pxt(ListaDeTablasMujeres[[(Edad + 1)]], x = Edad + k, t = vectorMensual) * (v)^(vectorMensual)
        suma1 <- sum(anualidad * MontoAPagar)

        PV <- suma1 * v^k * pxt(MDListaDeTablasMujeres[[Edad + 1]], x = edad, t = k) * qxt(MDListaDeTablasMujeres[[Edad + 1]], x = edad, t = k, decrement = 2)
      }

      MontoAPagar <- MontoAPagar * (1 + 0.03)^(vectorAnualmensual)
      suma <- anualidad * MontoAPagar
    }
  }
```

```{r}
DecrementoMuerte <-
  function(Edad, hombre, antiguedad, ultimo_salario, tasa_descuento, tasa_cre_salario) {

    # Considerando una inflacion del 3%
    tasa_cre_salario <- (1 + tasa_cre_salario) * (1 + 0.03)
    v <- (1) / (1 + tasa_descuento)

    # La funcion beneficio aun no ha sido definida

    vectorMensual <- (seq(1 / 12, (115 - Edad + 1), 1 / 12))
    vectorAnualmensual <- sort(rep(c(0:(115 - Edad)), 12))
    MontoAPagar <- SalarioPromedio * porcentaje_de_pension(antiguedad) * (1 + 0.03)^(vectorAnualmensual)


    if (hombre) {
      for (k in 1:(115 - Edad)) {
        vectorMensual <- (seq(1 / 12, (115 - Edad + 1), 1 / 12))
        vectorAnualmensual <- sort(rep(c(0:(115 - Edad)), 12))
        anualidad <- pxt(ListaDeTablasHombres[[(Edad + 1)]], x = Edad + k, t = vectorMensual) * (v)^(vectorMensual) * Beneficio(x, k)
        suma1 <- sum(anualidad * MontoAPagar)

        PV <- suma1 * v^k * pxt(MDListaDeTablasHombres[[Edad + 1]], x = edad, t = k) * qxt(MDListaDeTablasHombres[[Edad + 1]], x = edad, t = k, decrement = 3)
      }

      MontoAPagar <- MontoAPagar * (1 + 0.03)^(vectorAnualmensual)
      suma <- anualidad * MontoAPagar
    } else {
      for (k in 1:(115 - Edad)) {
        vectorMensual <- (seq(1 / 12, (115 - Edad + 1), 1 / 12))
        vectorAnualmensual <- sort(rep(c(0:(115 - Edad)), 12))
        anualidad <- pxt(ListaDeTablasMujeres[[(Edad + 1)]], x = Edad + k, t = vectorMensual) * (v)^(vectorMensual)
        suma1 <- sum(anualidad * MontoAPagar)

        PV <- suma1 *
          v^k * pxt(MDListaDeTablasMujeres[[Edad + 1]], x = edad, t = k) * qxt(MDListaDeTablasMujeres[[Edad + 1]], x = edad, t = k, decrement = 3)
      }

      MontoAPagar <- MontoAPagar * (1 + 0.03)^(vectorAnualmensual)
      suma <- anualidad * MontoAPagar
    }
  }
```


```{r}
# Ideas para eleboración de la función
# Aqui se programara lo necesario para poder estimar los costos de liquidacion
# Se toma solo aquellas personas que tengan menos de 22 años
# Hay que pagar un 1.5% de los salarios que haya recibido
# Se deberia estimar un pago que se debe hacer dentro de dos años

liquidacion <- function(edad, salario_actual, antiguedad, i, inflacion, aumento_real, porcentaje_aporte, sexo) {
  if (antiguedad + 2 <= 22) {
    v <- 1 / (1 + i)
    # Para estimar el aumento que se le hizo al salario inicial hasta el momento
    aumento <- (1 + inflacion) * (1 + aumento_real)

    # Salario con el que se inició
    salario_inicial <- salario_actual * (aumento)^(-antiguedad) * porcentaje_aporte

    # Salarios que han sido pagados para el momento de la liquidación
    salarios <- salario_inicial * aumento^(0:(antiguedad + 2))
    salarios <- sort(rep(salarios, 12))
    # Se crea un vector con 12 salarios de cada año
    descontado <- v^seq(1 / 12, antiguedad + 3, 1 / 12) * (1 + i)^(antiguedad + 1)

    # Se multiplica el descontado con los salarios pagados
    monto <- sum(salarios * descontado)
    if (sexo == "F") {
      p <- pxt(MDListaDeTablasMujeres[[edad + 1]], x = edad, t = 2)
    } else if (sexo == "M") {
      p <- pxt(MDListaDeTablasHombres[[edad + 1]], x = edad, t = 2)
    }
    return(monto * p)
  } else {
    return(0)
  }
}

attach(afil_hombres)
afil_hombres$Liquidacion <- unlist(future_mapply(
  FUN = liquidacion, edad = Edad,
  salario_actual = Salario, antiguedad = Antiguedad,
  i = interes, inflacion = inflacion, aumento_real,
  porcentaje_aporte = porcentaje_aporte, sexo = "M"
))
attach(afil_mujeres)
afil_mujeres$Liquidacion <- unlist(future_mapply(
  FUN = liquidacion, edad = Edad,
  salario_actual = Salario, antiguedad = Antiguedad,
  i = interes, inflacion = inflacion, aumento_real,
  porcentaje_aporte = porcentaje_aporte, sexo = "F"
))
```


Hola